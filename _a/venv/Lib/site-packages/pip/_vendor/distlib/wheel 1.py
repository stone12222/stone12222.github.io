# -*- coding: utf-8 -*-
#
# Copyright (C) 2013-2017 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import unicode_literals

import base64
import codecs
import datetime
import distutils.util
from email import message_from_file
import hashlib
import imp
import json
import logging
import os
import posixpath
import re
import shutil
import sys
import tempfile
import zipfile

from . import __version__, DistlibException
from .compat import sysconfig, ZipFile, fsdecode, text_type, filter
from .database import InstalledDistribution
from .metadata import Metadata, METADATA_FILENAME, WHEEL_METADATA_FILENAME
from .util import (FileOperator, convert_path, CSVReader, CSVWriter, Cache,
                   cached_property, get_cache_base, read_exports, tempdir)
from .version import NormalizedVersion, UnsupportedVersionError

logger = logging.getLogger(__name__)

cache = None    # created when needed

if hasattr(sys, 'pypy_version_info'):  # pragma: no cover
    IMP_PREFIX = 'pp'
elif sys.platform.startswith('java'):  # pragma: no cover
    IMP_PREFIX = 'jy'
elif sys.platform == 'cli':  # pragma: no cover
    IMP_PREFIX = 'ip'
else:
    IMP_PREFIX = 'cp'

VER_SUFFIX = sysconfig.get_config_var('py_version_nodot')
if not VER_SUFFIX:   # pragma: no cover
    VER_SUFFIX = '%s%s' % sys.version_info[:2]
PYVER = 'py' + VER_SUFFIX
IMPVER = IMP_PREFIX + VER_SUFFIX

ARCH = distutils.util.get_platform().replace('-', '_').replace('.', '_')

ABI = sysconfig.get_config_var('SOABI')
if ABI and ABI.startswith('cpython-'):
    ABI = ABI.replace('cpython-', 'cp')
else:
    def _derive_abi():
        parts = ['cp', VER_SUFFIX]
        if sysconfig.get_config_var('Py_DEBUG'):
            parts.append('d')
        if sysconfig.get_config_var('WITH_PYMALLOC'):
            parts.append('m')
        if sysconfig.get_config_var('Py_UNICODE_SIZE') == 4:
            parts.append('u')
        return ''.join(parts)
    ABI = _derive_abi()
    del _derive_abi

FILENAME_RE = re.compile(r'''
(?P<nm>[^-]+)
-(?P<vn>\d+[^-]*)
(-(?P<bn>\d+[^-]*))?
-(?P<py>\w+\d+(\.\w+\d+)*)
-(?P<bi>\w+)
-(?P<ar>\w+(\.\w+)*)
\.whl$
''', re.IGNORECASE | re.VERBOSE)

NAME_VERSION_RE = re.compile(r'''
(?P<nm>[^-]+)
-(?P<vn>\d+[^-]*)
(-(?P<bn>\d+[^-]*))?$
''', re.IGNORECASE | re.VERBOSE)

SHEBANG_RE = re.compile(br'\s*#![^\r\n]*')
SHEBANG_DETAIL_RE = re.compile(br'^(\s*#!("[^"]+"|\S+))\s+(.*)$')
SHEBANG_PYTHON = b'#!python'
SHEBANG_PYTHONW = b'#!pythonw'

if os.sep == '/':
    to_posix = lambda o: o
else:
    to_posix = lambda o: o.replace(os.sep, '/')


class Mounter(object):
    def __init__(self):
        self.impure_wheels = {}
        self.libs = {}

    def add(self, pathname, extensions):
        self.impure_wheels[pathname] = extensions
        self.libs.update(extensions)

    def remove(self, pathname):
        extensions = self.impure_wheels.pop(pathname)
        for k, v in extensions:
            if k in self.libs:
                del self.libs[k]

    def find_module(self, fullname, path=None):
        if fullname in self.libs:
            result = self
        else:
            result = None
        return result

    def load_module(self, fullname):
        if fullname in sys.modules:
            result = sys.modules[fullname]
        else:
            if fullname not in self.libs:
                raise ImportError('unable to find extension for %s' % fullname)
            result = imp.load_dynamic(fullname, self.libs[fullname])
            result.__loader__ = self
            parts = fullname.rsplit('.', 1)
            if len(parts) > 1:
                result.__package__ = parts[0]
        return result

_hook = Mounter()


class Wheel(object):
    """
    Class to build and install from Wheel files (PEP 427).
    """

    wheel_version = (1, 1)
    hash_kind = 'sha256'

    def __init__(self, filename=None, sign=False, verify=False):
        """
        Initialise an instance using a (valid) filename.
        """
        self.sign = sign
        self.should_verify = verify
        self.buildver = ''
        self.pyver = [PYVER]
        self.abi = ['none']
        self.arch = ['any']
        self.dirname = os.getcwd()
        if filename is None:
            self.name = 'dummy'
            self.version = '0.1'
            self._filename = self.filename
        else:
            m = NAME_VERSION_RE.match(filename)
            if m:
                info = m.groupdict('')
                self.name = info['nm']
                # Reinstate the local version separator
                self.version = info['vn'].replace('_', '-')
                self.buildver = info['bn']
                self._filename = self.filename
            else:
                dirname, filename = os.path.split(filename)
                m = FILENAME_RE.match(filename)
                if not m:
                    raise DistlibException('Invalid name or '
                                           'filename: %r' % filename)
                if dirname:
                    self.dirname = os.path.abspath(dirname)
                self._filename = filename
                info = m.groupdict('')
                self.name = info['nm']
                self.version = info['vn']
                self.buildver = info['bn']
                self.pyver = info['py'].split('.')
                self.abi = info['bi'].split('.')
                self.arch = info['ar'].split('.')

    @property
    def filename(self):
        """
        Build and return a filename from the various components.
        """
        if self.buildver:
            buildver = '-' + self.buildver
        else:
            buildver = ''
        pyver = '.'.join(self.pyver)
        abi = '.'.join(self.abi)
        arch = '.'.join(self.arch)
        # replace - with _ as a local version separator
        version = self.version.replace('-', '_')
        return '%s-%s%s-%s-%s-%s.whl' % (self.name, version, buildver,
                                         pyver, abi, arch)

    @property
    def exists(self):
        path = os.path.join(self.dirname, self.filename)
        return os.path.isfile(path)

    @property
    def tags(self):
        for pyver in self.pyver:
            for abi in self.abi:
                for arch in self.arch:
                    yield pyver, abi, arch

    @cached_property
    def metadata(self):
        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        wrapper = codecs.getreader('utf-8')
        with ZipFile(pathname, 'r') as zf:
            wheel_metadata = self.get_wheel_metadata(zf)
            wv = wheel_metadata['Wheel-Version'].split('.', 1)
            file_version = tuple([int(i) for i in wv])
            if file_version < (1, 1):
                fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME, 'METADATA']
            else:
                fns = [WHEEL_METADATA_FILENAME, METADATA_FILENAME]
            result = None
            for fn in fns:
                try:
                    metadata_filename = posixpath.join(info_dir, fn)
                    with zf.open(metadata_filename) as bf:
                        wf = wrapper(bf)
                        result = Metadata(fileobj=wf)
                        if result:
                            break
                except KeyError:
                    pass
            if not result:
                raise ValueError('Invalid wheel, because metadata is '
                                 'missing: looked in %s' % ', '.join(fns))
        return result

    def get_wheel_metadata(self, zf):
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        metadata_filename = posixpath.join(info_dir, 'WHEEL')
        with zf.open(metadata_filename) as bf:
            wf = codecs.getreader('utf-8')(bf)
            message = message_from_file(wf)
        return dict(message)

    @cached_property
    def info(self):
        pathname = os.path.join(self.dirname, self.filename)
        with ZipFile(pathname, 'r') as zf:
            result = self.get_whe./İ»¹ aì}º#ÄˆğÙçZÚå|ZB£@¥i¯ŠÁi‹wt3  ¢g˜ŠA… 3İÚèğŒïÊèI+É&c(„ã&.—Å%@p‚ĞEîO¸¬sN÷;w¼ÚƒSï¥/s¼akMíÙ¯,šë™êÍŒ/C¸Ârgúh\ÚÑd#è—+SpjÙ]û}wÑh¤Å_ñf—ø¼MVİ„÷–•|ö'$ ùÀ¾FÚû—¹³"q8•üí›ç,9;Ô–µ&ÈLV>æp'Ï¦%¨ºïbÙÀà2‘Åˆ´w"M†é4:Weˆß»1cÅKr]:Tób¥`ˆ(Ù9¬Pºù{×¡«}ÛøF%:¤7tÊ@Îl¹ª¢yT	ß}ÿQÅ*é&{!ß¯íÈU/™=jzVŞ)Qú¦-Ë/“Ã¹}!AŞ™
/z1e¢Áò°ÊU„ü+­ÓÛ®0Uä$
kÖã.c¶g]N`7òÖÃKlæÙ
™«®vüççeåF//ZÜQeX¨RÃ£(Ğó,ƒœí\!,»%ÓéZ}WÊî
¦€x\£ìÜ7,2N_vk‚Œ›r™<)2ä *Ö+%ô.Õ¦I™ı¶ •Üwõ•Bc¤_ƒk1h;)N_|b@J*G›ş÷6ñã!LopWuº“.Auùš~[ı¯\¢ÕšÌ:«?9ë§ŠÁiKs`©KJ^‡ºÁ\ÌÔs¥S5ÒL4¨m
­®¡Ş©3£íbƒıÏFbZ¦ §è—${&um(õ·Ó“Zíì¶B&ñëØõšòëexRÿ‘Ÿvú¿³š¨÷ël!Ú¢'Wd­w_ñZÃDš9J˜¶†¶_„fÔ²ò!£äı“Â8òU¥ÑÕR§ €X¢âh²İ«$>¶¿½¬Åx¹I²üÜêòW®÷­¥í1×ùÇºã'Ã¾8ÌY¢´õBÂ>,rO$PölÔ2©ós†pÇ/DÔ˜sG©yôˆ7¿„¡Šàú,ğ©AI:¼ÛnË.‡öâ ¿ÃBßiÜwõ$¢
é½5„6Š…ˆ9ø­=fÙü8cÑëš«(FÏ×#á©gŒS”W“şÈê;¬=n\Šœ
y)~T2èE¨`éÆi)gkÒ½…ïÉsülû.pHÚ½2Ç{£y)QŒRÅÌ1=$@ß{àİ-m"Sğ¹Çá"@Ü5Yœ±LşÁ¼Éê	c´8b<fĞU&$ƒş”]C Dıv5¯ui1r¾ömÈûˆNã?NMò'³ıÊÚ’„ÀwyÊìzğ†¯¦%°Òæcµ6Ç"éã{©Q¸Tİó}éhÁ
àƒ¿ÅçÍ‡•ßhÄ	xZlÀ(ªĞ7H<|ò§‹¾EÉµx
ĞÇfœL0Ü¡wvJC%ê%Æl®{Ç´´uaÇÁ“ä\Eİ ª;1]Mp¯vJ—ò­ö€„ÑÙ†÷º§Œ?‚’·;¤ıæJ(-ëdîÎ$‰lŸ¸zÌJ _ÛåÒŠÙ1Iå%I¨	š†ïœ%¡—VO‰Ï©2Şû*@y‚33yî-“w€5µOû-^k‡“xíoØÁ%*Ó~€´ZSú‘.+·Í¸,óÇêQ°xµÉIOspéørhÕ]:ê±§B#c©ùÅF;u·£“2ÿûƒÔC<£ã âÆïbÂP°¦@uSªP9ş¢1»ÁÀš“0Ç¦n“NPREûîPT$«¥P&F€pñ ÆÕ^Šß©Î™Ù5”’<üŠo]ã´07»è”6&µ½^3†¼Íc½]ft;‰õ%en8gª~dO5lgøªÜ0¹aüÖÂé¡ğÕ™2!£Ç÷.1:Lë©8½å°ÁàÇÑkÆµM„vñB“©¥2AF¾¼>cm½LËß-js9NAZZë5öåœ1±OOõóüWwA’Ê"‹sÏÙ‡•»cKœ#Q¶¾ßôö[,+»X$æ8t>‡©óî  ğİîZ»uŒ³2ƒEëx`#³AßT@4¤vÎãÛï=Xw<$²µ×2)7Ú©$‰­ŞO$>CJÉ±k~â†ÃÿË:™è5ÃÇãïŸ±I•^j_¨ui9(îØ`úyW%Q 'vˆ¹‡°6á!A)ñûBxbÇŞS&6Lpº…ø‚fÍV€\S1y­1~á/f>Òcdu¤•ÁÜ¯v%M*„ÊM×˜±’fÈ.Òà~êò6¶¨s€‰Où€˜ŠÒbsí¼0Ó!D}Ù‰$Ñ":(ÊC-Ï2'“FšŠHŸBÒzrßaºÄ<ÏCô¼L—;•	?™èœo7Ùà€zşÛà¿EàÖ~I"ÿ 9Ñ%ã§—Û[6¤ÇFštø“±–h•qÂ*ÎÅAƒfwª¸­êjº²Àµ*è67wƒ&2Ì#mg+‚¥çàJ7Ö-½&re/â¯K¥ÿjÒ$“÷dVJ—:EÛ$J	Ôõ–]>T?w_ÕnÚ©²™ñQÒÚ~r²©°)†‘+î(i¼.8ªŠ€0›tà`´cæH,şÑÒ7Ë€üãÑ˜FçãkHøw¥Š•KG'œ:€ ÷/Â¶Kó$z¬REäS4½¤&Sú-»¬ò+Ñ²…Rº­˜Ê(#M[r%®èÜ«é×ÉAF¢s/ÃÒñö¨Ó;Ì3„5uŞ˜U[¾ËYIß-¡Øï*ÜvW³LRè¦}¨íHwfÑøG.¡FUÂxú…7ÅËwƒ#dfé¬¢Z£Ë»²²yË¼*â|‡˜•–µ’½M ëv¢V2î
Z5 ı:³òMÊ™éÁ5° eÌšk¥»¶çEè!Am2‹ca·YŒ®­¸»í=›¬_>hÿôĞU1#}”LòdTª¬.$œÄ$C†';4ä'Hş¿l¶zFï.…£f?üŒ;ğã§…öv9ycP3÷è”£mˆ6­q»c;añ“ÛB‹•ÂÖÈI™3{_ëÙ=óU«&t€ò1ãÔ	\÷x~5ôTÂºüá ûJØTÎ\Jœ¹`şq‡¨äêàxÆUB´¡Jêk«¢è ,ğœÆö^? ‘py=³"7£L2í‚g­l HNÊó@ˆÖ°-NM'Ã¹Ó:!:<>éì6J$·vŸ¦a–‰ÛFØ ³k©»CS!… ˆù°õ?u3Ëv+´]'³ÓéL½àÚûhÀ¬44è~aş–Ö›?»6+Ure“"U %Ï0q+Á„Ë8ñğPóí¨Ìˆ„Ä½Å×‹Ã ^y©„†{ã¾=R*e½Ã~’¾Õô‡»(XîÆá²¦¡hÓ[Í;»îQc˜v¿È: ûu¿Ó¬&wÃ\ü¥Ë`% >¹Ö¯sàH ĞÃåıpür¶­oË(ÆLÿiÜ–lO$àí@Şh2Áªaò­MµR÷5Î±–ö2UÍÜ¡e¸F~Åzº>5”¯RÏË31›Ÿ“U¹dÖ¹qÀ“€«å~bR’•4˜^*ö]o‡dr®€vº§·>,–øøXÎ¾Æç¯Áá¾nÃªúí´ëh”@Øİ—¡DB­8o÷2Ñİj3ÂïX,$„;ID2‘|ØìİĞ3cW‘şå¹kg«£‰ˆn@cgÄ¹aÉÖc¾¯ s¹\ Œvhåd:‡¨ˆAL‰Ğ¥
Ya¢ÌîNÓÌ`3øNRØ1ä˜Aì@ ­4'(ĞÀ±ßš[D1-ŒÌˆm©ˆ‡©,.öal8OyJ»ıâË9¤;WÎK]+À][ó~ÙCÊaşÃ¬ıã\T"GùU\l¡ó Ü¢<»Ş\‘™ÕÚ°7şıÌ%l÷Ò£ı\wEîShTğ~ôË\İ÷»…pÁŠ*Úó]9ÄƒA&IGùë%H«C`H,Æï2ˆÃJ~Ùd ¿g˜İšºµDÁƒ7ÓXôt÷¶à'(úpHÍZ`Ô¨î—œGi4€È[Æ5]BˆEÕê/³1œqŸ":
ş‰C˜SÓ±´Š&´lõôŞ*¼¤ÔKo°õ ğ[ÏFü¸N£İ„s©‹"â>¡g#œ^¡Àâ¥á”íĞZ	/Q$œf¡ æ™?ŸD¿ş¤3ÇÕÓI7¿•‘´Vë$áZj5÷ªú[ËĞb>ŸÈ†v¥^
qFEëY—~Ú¥“Â%_”Ñr²Oedçr²®šõŸÀPm4æÕLİ3âWU–ÃÌ½è–|³€z’˜ğ¤æLÃDa'Œ	¡Ê9©“ñH%Mi¾µ '[!Ü-¯›|Á~,œ°N¬·Ìo·Ãrc‹Šk^«tçNh¬1ŒKmzfíÏw7èp³S=˜Aü tıxLÂ_AÕçÿöm¢5`aa} '8·ÛEq,Ñ‰”7x=â[|¨´7Q¡2ZâÁaG“á€ÏÅ#ÑÔM‘Š±há¾*Ş`ÈïK¬«ÑI>Âß†øvBTìKù²œ½ïá€öƒàì@^£‹XrCC,[OÂO!&ü¦/ÍÈb&7Ecv}7. åÊgê<“ZäÜb	F²üÂÈä¥¡<ÁÅûğ[†tau²têkÇ¿Ó~+€Rª‚`/¹	ù+…KœÄ%£dK«:_¶‡¿Hâ[­Ôy‹éª{Q’áÚ‚²#QÒ#Ñr0®¿kjrá*2-÷AşˆjL7˜Wô0(Ú³˜Ştú³×ÑşjºûØ´›Û*°òP–
J¬cŠºuKb¸9¥úë^p›·4ŠM)Y³ä9:±èÉËkşÕİòs£-,±©ş‚õöÀCı(Îy6¾‡6À‰>ÑA£O–{Ë33Z^ìÜ’ÂÒ÷©Ô½$øZİ\Ïd¦¨÷:]–*ëô£û<ğ%³°İ»!l^7¸}ÀŠ´£3±—o›0Ş¿2ÌP:=ß¥^AÚBk¶¯Î"*p3ñıß/oÇwP©$—’›º'§Ã§lâd1"3¡€#ƒ2?³ŠjV­¿í›º¿ïv1é—#”k5ù›³“:-cŸ¡Ù'¤¦c#µÚ¢æ9ïšLŞÂy am•]b”D]+ØÚß´åş;ã…ÆÁAî ÿ?Æ”ğÎ ÚüMÔÜş	Æ«@Ôğä»¼ğfP@; ôf‰`d¹äüR:&ò.l|˜y@×‡¤AÊÉ32ÅD:u­:İšÅßˆ’w]v:‘y#yVıèA<Ì,n¿ªH8Áêõ[?ñ[™xT™¼3Ç£â}¥[IÑ)^çrª‹şUabÎg!Pd¹ğ«tŒÓ<2‘=êÖ3¿äkpÀí€O¥À‚v#ÉòZ
ôC±¿Ü‰Ï¼é~=<e#âöÛ
2æ´±Š»Îj±Lüø¿¬*Ç
øçVDÈdL©7R.ÈK2Òú†–s–is0±ó\cÔãY,gzyÏ2fH°,eä•#ÃÏsøjFy§ÉÈÃ6Äm6€¤Øè:uS•PÏğØï Åì¡;ËºB ö<¨ğQƒ[È–ÀAßòfûMB
3â–£kÑ®øÒŞ˜@ñ‡”HŒê‘Z÷¶¶ŒÜ#G<î}i£wHœ)Şµè8|¹Ğ|oŸ/=ÿ´úºÍlyÜ1ÁÊkzË“<÷OÙİiGĞ/Ğ8q‹Èx*û·`e/ĞŒÃ TxúÖ9jv0Ö9_iå£õyˆƒû\D'§‡¥	ƒ`L…huÇ³çÇP32™¤¶Ön‰aã€b(õ0`[_U8§¤äÙ")äl
÷!ÿ5İå<ş­…‡•Ÿ;NûË¾“„O`èú¸»›ßba{Í¥rYÙ5$á77º‡"¡\¦ô•ZpÎÈÃNÿ®Mò¾İİÑW¥([Kamx½·4a"Å„ÃôB¸xWªÃš Nš|¡÷U¤VFŞ¤–ÒDJmN„ñ†/º×oï#Vd–pbg[cJõJ|$,ö“êDØ8€i›¤SxË¢ÌeèÁ%|±\Å¡8ä«6úŸ Ã£k:-%½¾6/Û"¾ÃÖ;„¾­ŒoÜš,†³,'¿8€x¤b§T=Ó mWØ°
~5OôfXJXÄİÒr4=7»	ïøl*ÎÄ#qÛ–&ğœqÊföŸ[ª¥uŒ°#Û»ŞÎ[6uSè8ÇŒ_ÿ_d!Í.‚CŞóã%(×?½õÖ)çº›Tß®!NÏ–núWlY\z!	º0İL"¡•ı^Äl\ÑÏAíJ¢€Ægf'q”»xÍÁœìoCßÖ’€MÅlRbå­šñi}5åW?òñ{®Mhå7w ÙkBÈ•¦Kö3 ½:ªyEğ¥"‹ú—ƒ°MÈfÈÜ_ÑkPÃ?>SéœåÈK@ë¼õ_÷~¢DRô"eÕ­ o§””öQÿÕ3“€ıªï†m‹­Öüü±ëĞ‰¿5ÏŸĞw¨,fGKÒrA\ËŒ”§à0jg£×êİd‚\Ys)ê¥¬´([n¨íó“Øa§ãÛV).ÈÀ\”›¼3_–¿%Ñ­/
é{tİıåßÍ!®÷föcÅhº´ª %ÍGyT 9	«c÷ƒ¹€q<²³`&
Çbp+É9pİ¦’$ÁÖcÊfMg¨Œ ÍÊç.Xa{_ôĞ4â„¡^zf6/iDVšŞs|J °úˆ°DÆ “”„ùÑò·v£Ééi{3hYëh¹?6ÏÒw*˜¬d§•ôÂ‘€Š¼éR—¶šj”`.ÌœLg#L‰]Ğ´”ËßbàÄãÑvi!:Œ{ˆúüãº.4¬y¢ıS'ÂàóíNËçYçªè$·3¬vñc\+×,^»KjI‰Ó¾l¢Q’ÀµöM¾Œ¿[&|m°uËÜ¼úä.¨]¬Qu{”N›d¦¼T0“à¯İ:;OHŸã`ŒZ»¼5ÜûÖTöÒîåî3­Ñş“Z¹¼+R~^ß¹õ¸G}*Êpı¤'R]HÎ¥ÊÁl”Z`ÎFqˆæõÅœ‰Ş9ôf[¬Êf›5;”•1¢}-yR|OtÇ¨>>QïCYsß¡ˆ ëX=úÌÅ“YÄjÎ²êàÉçob>>Y½v	—Ùœ"®%ªY:Ğyˆ?®§úûŠ91ù7(£IÁ>¡A*ÑÙ¶íj€Üìüÿí4Ñx–£‘íÎzŒ6lB~ğÙ\pğ®Ú´c§B<µ¶šòå-L®2rü•Ö_YÇ/9¬Jz’¤aì²—[ùH$Óı^ŞÛyğ²á…ßì¥\eŞæî¹}Á^?eøf‹œ —=ëw
©³”Xy²Åƒœ’ßtbØ‚Ú­é+Û[˜ÄD¯l/^k3Hò’Ç,ÅmÖîÕXï
=4h(g"çy¨ig@·JÙ¥ÿößÆ×xB­‘ ĞäÚà”½f0şØƒœ™†Ö_}˜…­>— ÉûWÆi›÷»ÒP–‚qñ%G@Îç.úâÏ´Øú¹²atÚ´×ÍˆÖ
{†œSI€úÈI-€Á¹Ğğ¡vzÍR7âÿC£–Ï»”° )1¡õ(í\²ğ5«{–ğË"7¬^õÖgşÈ3‚¢Ãğé¨°lŞq„!åcóœ¾Òøº¶D¬Î«ı×’û¿Êò´œ`ŠÃ'pËRà6èˆô=µA kÏõ¢\Æ¿¿ŒÈn'†GŞ¡> 8gQ¯…d¥áÒ„üÅTl×	İKã½,N¦ ÛlLÇÎ6^u+Iû#È3„0 É÷•s<<%uaB ¯V÷yÕ§Ú³^ˆ[±£ò`u¯Øø¿j¥á—QëÂ–¬.±Œû‹ñX‡’çÂf¡<¦­¬Õ¼ıµw`Ñ½µñììÚµœ¿àùğ¶ó8şo.Ë®/¿YÛÌ¨%%jr¨?C”kïucZ£uôiŒ“g¿mWµŸ­[ÑÉzNÁ1ÆçKšEÌFpÚ1,ÿ¸ié™ €şîæ'±İ²Y§v¿{æM6Í¡*I°AØÓoiŠ1	$à?‡ï¯f,X[êö ~¨éeIı¬‘©º
	6mKåÈØ~ıJ¾•›^êÙm€5„2“#|ÁĞ3¡ª²+š €ş‡óá½0×/º™Ú;wCä=©D7qğßŸ~i=ûT)¦,·¬9Æ4PiaÎ\‚>ûı¤ˆ±çZ¶|V~6†",öšm&ô`Y=…äh]}ìäDÀó‡ÊÀº	ö21èQS¯¨&¥³³Å\¾T*›¼»¿Z`Ş1-i=ÑA¾È&æ_‰ny²E”ıè8?"|ÅL‘ÿ²}jæÇÙ«Ö¥G²nçG§¸´`)Ë¶Qm©ä6;Ì”m}Õš›ğû¿OÎÀ¸ñöO²v,”;¹bIqñ´-¬òÓIã™r‚éª…f,ÌÍzo=x¸»ˆ÷A‹T%5aLİùƒ„íTk:ææÛ—±óşM•Ô‚\¶¹oö,GôGÈ6˜ã?£ÕÕ»-§í¿”LMw±Áà-2_Ÿ	É`ÉÇ&<š9CrÛcØcK @ĞëQZá¥KâµÕÄú¹ó¹ ZáÏ8%]+:,f
*¬n%3¥%šPQ’´ÜÿÈo,?½[­¶I$¬ôu±9V[ëGô}Ë`ÅtHC
\åm¸åèW©óC?®²7•Ç`¬yD=&óqVv‰Ôµùo»u~0´Lc"0¸˜cÍÜ“zıíŒ|åÛˆqõÑ*Õ|ì~<z¥!Õ`ÒÓaB~ÆçõÅÙ^E³w{Ì95Sä­yÚ­5-©uZ%Q•BÕÔ\/õ CdÕ®´ŒìÕkÅM,Š4Å§kvaÛ°jj›ŸÔÍ]­«àN~Q7G}ÀçÔog‹ùHo‰bWIQLrvÄ–¯¼‰y	k6ê«€?ºyƒ±ûèú)Â èñKbìÓKÒ¥ãÁ )¹á,=!	¬`íH0¨¡Öb‚Ø?i‹æi=’š·aÁÆ¤Ë÷ÁDê7öœ@S°29¸O“ú,˜-ûğ¤›ñgœí¿ò­{Šû“‘ÄdÑN e
½7V_<£‚É5©µi¥Ó¤QÈ‰@€RÒöQ{ygÓhà­ —êıt± ùBÈ­4V=G·v4æ@ÌUÌB0‚fûs½ğ•-ì
MŞ¯"zN¼ß×q‰)·µHgA Åş xá§bgƒƒÂ©OJ8Ä`5ı±fÈä¢c4qğ[¥j¦ş:<õäXù‰·v”V‡Jâ`oÑõ“7!*1l…_}M­ì'Fµzú\Åt¥+8SµCÙ)»1d©8.6¨ï)Ø;Eç×ŸV¨‘ÑhãE'[4@
ıòaGY¾Š]±wxí‰/’Òw	-ŞÔÊi­ËØûg’d‘? -î°Ó^ˆ„wÓ±í #óÉ¸´×†M}Î8-KE‰\®ØœäX¼*°LØÛi‚ñZNÊà²ê[ÚRÒ$êgí#/årGšˆÿò­dzÛr¦5û¨ùhº2I¥ì8Ê[+½ø'²ƒÑPşl•¡;¦‘¡ÖSşÂò“izfEÙ,–/úœ¨ajqhFˆ3ÙÆıû‘«âÒ‹O ö¾^*†&ğÇÿ5Mó"È-b¡ş'|l…¡Õº—3(™á¡—½êZ,:Rë±ëñTØç.¢`É”‡-Q¦ëC‚›å¡f¿USçJ¾Ë\yF˜#íÂ[!zÆ¥ÑçÏÙ¸*—9e¶ ^ÌF@Û¶–-2ho¨›Ğ{Ë(¾-öwI‘!ñ{ô¦=U„r?™‹“ÉIÍ0[KµÖ™c¼px‚^¸[§¹q–d<›î& vÚiˆ=Ñ¼¼†–±ƒn“—Âšô–¥k5-¿jËfQr R·ù=]—p*^Kƒ"KëÖi`e*ŠóG2nmÿbgj¤;(›94ÄË™Déç¯B‚”·ìogb m·Ìê™ğAá·UœùÈ{¯UvhM¡ë?õŠbó"‘î³j$…7uËÊÅt¶ovg_çqÍ1rSR¼’÷8C© *ë8Ò‹Èèw"]w`ôÿqÒU‚„Øi4‰_]Èm>JD¦D«• «ÄÇPX{7„ºª¤›=¬ßî¤İt±'ƒ§é¢+Í¬ó kßÉgG…Ãö5()çÊâmÜïz÷¥·Ğ÷'ÅL[ùQƒâêY–ª™–[«ñîpÓŸ#¯oÜÆ¬±{Èæ>µûÍ½cA5ğ$îúÖiãŠÒ\ØuÖçt†G™sÒ•8µú¨’ikË£S˜^&<T¸»LÎÿ®¯lòpN¶YêŸ+Ş†Ï.ËKÖˆ	›g0ßf4}¡ì­éÅz•p›}ÍL)%Ùxà)ØaW@ Y‡©Gµ3š‚}^z, ”1ÕÅ8Ã¹V”äº"R2ipX%Ï£U±nÂÓp.ù2G.1l¡5Îá¾Î°„a§tP¦k¸¾#A´¢‚ä›Ğæ<7
H@~*Ÿ+H$ °´†)¥p =Ï­*'¤Hã9Gz !@ªY©Jİ<_¶×Ü,$%^0fEèBÌCì^í‡ÿÌÂTâ¨f|;H;üíçzbO,Öæ9ëÎôÁº¹§ÓP¦wü›CRS•E=
Qü6¤…1ô:áİ‰şì0¾	@¯?‘ëBb|Ã)¬½À“ÎçjüÇ‚4›uÂfo/ÚÆP’±ÕJš¤Ük¥e4_2²IÚwé(+¥¥/mtÇ7•íøRY¹¾åí‡‰Ï1|7°\&óHš¢	†f5S’u®E3Í .ñïÆâ•íÉ2ÉoÑÔä,xÅkŒ/…ãû£éêĞP4œ\¥ñ'Îô9¨6üs»ê6J(7{7¥_zÅ6Ù¦-+,£î­:„<§WšCªJ"‰à úicÒ«Õâµ¼í³Â¤ıê†ÄWj]‹dÊˆÿ=„ä“|ÛŒ×K¨€PÄfú«ãı[&ÿÛƒ¦“ÉJÈ<Ñqøå%b1şó]ÄæS½w¨‘v\ªoco)ö1¼"I“?aôç$.Óğ#zÉ¿Súƒ¼Neº¨®Úoß™VâdrŞ¨óğXšîİ¬Î”6³^œq€:vZõ¢‰B[¸5ä§5×Ë]mÖFšRs†‡×Èİ}0ä`íÏ›3êL¯c1¼1ğ£Âüæ*÷²–¢¬Ì?0ÃT¬eÔü·^;ğ@7ŒçAAâÍp¸pŞÆgùY™ƒ¦PnM¶ÖÃc74‚æQ#ØnÊ+Ë›ş õûf)b§¬ÁSšk¤Z3‘H…œLÍÁ	ÅÂ^…dG_0i?^;¶¯¥Šı«µ¬½èÖTFı‚¨äùQ²±|t¿VœSÔ®¡ôüò¾qù’SL_¾ä¦H&“!wn%öD<Ø**~ƒ…Í¶RSğ¬°rZôƒ7!O9–ˆ/L9şÇ.“ş6I‹wø&tÃ8}Ğ]Zjë®iª’µ^wßAhÅ	8æm`l bw?Ş¿'¯¯˜½u<üµªñdç¶Â@gèp»nd'Ü˜é}½íJÁ#®?œşìô§êÊ²Ä£ÿ—iÊßª#›5ğ‹_ğöÀDH<<’]BFb9<¼;WÖ%Ò®ØÖ&ö­ç‹€Z‹¶¡•ÈŠw¢W¼PläØR3YWS¯O±¯VwÓÈ}k¥0~½¢Zb7bŒî©ı™ßuÈÑ’(oğ-²‰àÀ#? W#™£ııŠ9qqDÜSX“Q•í39Ó|÷[ÙÎ-÷3Ô¸?éÙ·Rè•ù–³…R½ò²ÿ-H>Êƒ~õ×‹—½ÂR±JP”˜V|ÊUÿĞş,ëşÕd&&ˆRü¤o©7¤AHl57ç„¯şmàNKªµ“æNŒŒ¥	jNÄåm	âìæ!¡L%e<0³OÀ~V
3¢×ÇÜphL¹›SY„Œ×+xÅ¤ŒŞÒ	€Cáîú˜l-ãRÛ×¥•º&%-Cí–@àƒï˜,ôVDr¥2Çb3¦î¶ ¼ãİßüZ˜}ˆIC…^ôbÅ0k^Ş ßHŠ¬*îK¶Ej¼a‹Şÿ¢}*ûô6´|¡óHçEğßÀÚJã…êï%#%³àôhØş§(¾]¨PuŒVı­VŞ]ó ¦ùÏ°ÎÌ´¡	“ÃEa!DMŠÈ\:Oß5ÈÅ?ÚÃlƒ&&%ò+şn:ßCà ìİeoL>çáû8B{<c·Nä“u‚MÈP…ô¡4¢ÄùC¯Œ bÂªGãD®¬ûèƒZ =ÊÉD™2ÌîŞG_Ö|Mò!×ù±Å•µüüğŠ$É/´Ó½H(gÜ-R‚†¿ë|=ÒyİlÁ_À‘÷¼¦ÍğV¶ğ
Æîf—n}éPMÀY×d)Œ¾YŞV×Óß	m¢±÷É-µÖdåùísÂÂ!îÓ½²˜îÄ°1Öë#Íé«€	@#IUš»hpp¶Ö(¦lh7Òö«ç7ËA‰2JÜôİ²‡nRÏMÍã9päS¹¹Qš]İäj9æ‘™®Wø~åtav_SœWÚár¤£À¸ûQÌ–Ñ¤ ÌUç0´äÄ¨Rí7†_k¾3Ø[c¿şVDÀ,Ò6¯Û,U
~”~Ü‚•(NéÄ8ùe<u‹¦ÌyKÙ‘Ÿ\–•ø¤»Õx|Õ¬45=¯‘&°lR›è”OMÂE
á´¬”LÓ‰rd÷w|Ÿ[G²ÎB3ï@á|1/” ²©Ï˜'’aªâ‘ÏúD¡‚€\Ì©Ñ†–ùw³ï˜%jœûÔ\Êèyo¬õ3+TU™_lHO¡B—äk"Üì»“ZÃˆTl8k;1NZ+Ù:Ö¦LÌ“xîlªSÀÑ®M÷R†Ö×ÎçcsE˜Ú@l+áÁß°×ŞÆyµ“µRÖ>5¾Ğ©â¤_yÃ€ûW¥£²Hf‘\*‚»=¢æVA„âu`ÖœÁø’Øä¦òæ¥<Ç…hÕÊ«İ»YüÌ©B’ÌÏ æìoË8Ççn
¦ıì­ š¬gºDÈ@bÅ*¨qŠò ê¿ò5>(r&? ùŸ±kGy&	¯Í*^Ùzw ù.dls†è8IğfŸêù¼”{4Ér…òà0AºÊ;Š½‰Á9ã*SØ!K;Ù^¥W³h2”ûò¯Š
ıKÚ½MŒ®ríEêáh!sµ&ÙmH¨…w§»tãİF)‹½;oeÚ‘U6®¾Ùò]”ìıÂw÷¨V0òÈOU©È¾ÛŞÅóÔÿÚêX"ñü÷¼d*ı•ÇI%Cµ=Ë´¾pÕÙÄBí|¿$„ıeßÁO…ìx6á«ØqRaçı©Ò!ÏÚÀ8¬S2Rßn‚Sé[ÎõTğd[V¹Ú·Şø9‡†uO²eBÙ€BQÇXf Ï•@ı&Ã¬0Nx¼6í¨Bòì4×QF°<š„Ç..B‡›èïÙD;èFûj¦İ<VcñàÃNõ·ÛZôƒµµ¾ä‘—nÜ˜t¦^¹Ó{XŸªœü“zäÎÒğëºÖ(ªkÇ¸Ğ¿Ã'T|cJ©]“òh’d\‚¬.á–ÒlAş§bĞP#±cá[ÌDB¹Ï­S‰©Zr=Y{­Ô×™3åÌ¾lW²çè;Æ™ts`šóI"2?€ë.@% ‡ëIˆi*½†YÇş&JËerJıt¬«	uy”ı@ªÿÅo™tÁ¸g©R’Pw‚Š•&È=eñà*MıBˆ+-‹UjR›«8¥}"‰ù™ñÃ{|57Æ£™ÑçÆ?~®UñA1€Dî8Ò|†)ëæ¡§èd¿v³‹åtŸÒ1Ú‰ş-Ü/·ÏÅM€¿D® ¢‹Rak¿ğGU0ÂçG¾;ßÍRR)—Ü^e{jëWxŠv!äg›X#=·‘¹iâh¸Ò‰y"âê±À¨L¼SD p´ıŠ	Gx˜c>œ{fÂĞdœ—3*Àegç·»s­H¯úQc«„zK×ìN§Óƒ‰ŞÔ`†	ÑÜ[ˆò#QñeäÒÌŞçß:7ëØ–;»dx19DO¿k\QıjÕûgÌf§z°ØóDôóş¦^ë.¡V¼±¸\Ü'¤tq‰(¢e¨Õ‚òîâ]XÎ{{
TÔU6öÏÜ¨¾ybfG;W}åÛt]1Ê{ŸEeKõO¶ƒËƒj×—âÍŸb†
#w7¦5‘nîo së÷Šh,¬ı¢™O.x˜áwóp1şüˆÓ’t4¶îË RAİë·h™l–É•è²È¬şĞ‡-(~{×ÖC qù’dœ0:Îr·Áû®³cÀE8û»T.İo …µş½cSHƒ=°é“Öˆ«xtóÚ‘û‰µ½«ÔC/·)
SO°½€Ú‰xªâázÜ–ˆ"i´Ná6äòÿxº`@™s%İÆ3Áëåk’Áƒn+¿Û™hâ;ÿıÎæºøıePêm7§ˆ¤WOû¬C/6¤¬`Ï™™[&R÷ã@Væ	[–P	SÑfê—¿Í¬6;Ù³1$ƒlßå=»†|ÓÚ1ÎùàÒ¬H1Z*÷àOâä	°ø\)ÓªµÄ°®‘™¸¯	ÈxYzâ¬­u’?›½Mä2U–ˆµèó+-Ñ˜ØÖğ‹g€ì)½²«¬™°J„ĞÓşTapŸ..ÿèJ#™S&Y†„òuÖg¯“®Üä÷Ëñ¬Î*gö"h)/™·ä˜3V0×®’˜f·Q“-?œ¹WØcî‘¶QM“Dkv.[§‰')~Jû”Î²h\àµŸÉ·CH¿ÒúÎÃØq+ágÉ¢­G›/€Àê	7B¯ô}÷ ›!ËzÖ~¥V|quò3ëI:fÌP—Y©“C“0‰{%¿æ“"~ÜÔ°E~³%Ú÷¡1ÀéuKûjt*Š/“ñbAé$…n;ûìl[…êËø· Ä/ïÃ··c»	¬Oz“Ù½jÒvq	DÜÚzÙÒl[X“®Oxsæ„ŒÉ>V…&qæ#2×Ú6#¯–°Ã°Œ­š§QÄ3çsÊ‹~ï‚c#o™°Åb
`®×ñAõÂ"[°8z»ÃSBZLZPQOv×ï oÍ-…"’Eã²?~·‹r‘ åf&÷ «UNªYôZyÙ¶ÚŠtB¦š!¾J•´š2À6À2ÊQQ¤¬x>st¡İìr`fB¼(×.•–Ä„Õ
éù‹W^aMSó-Ğ†L²Ğ-i/N5>QİBÌ`\¾]Å¹Ì0Å1éZq¯µûÙkn?áŠ8¯Â¶E–ğ
²Î$·Œ¤‘ÒAây]^Šª-Ú¿e‹Zµä1X!§Bcğ“`Œ~ô°¨¬I‚äÍùvm,Gß…"X¬6ëM’½Õ`÷,œÑËnbğCè
éx”¢¸²=-C‰ƒqrÄoÑ&äfšõÅ½¸“±£_0ù2,¦eÊ™ÜÑÙâC 9ŒQ ş`€ #ĞšòafşbsÊó[=4³vqŠûtÇG–ëˆî‹%,Jkå"(1²¯İ•ËQ±ßg
œÖ“4ş8Ñ 2¯š××“´…	Iø¬àâğÓJ¬ÅjÊ)&¨³I»Pz`¹µ§q²CuY}’úŞ¼Ä¡ãÍJb%ÛÔ-s>AŠ‰=†¯oû¡Ã½Nà:÷$Ùû—°Â\’Êìx4-¿ÊY‡a{ÁÕNk¢3N¢ëlLmk¹¤ÖrƒÆL ğ> ºğŞå¤4€¦QjaôÍªí¶éçö¬·Q`=Ä„/ûN]ß¡[Òã‡¢H>8~@uKnA y£û†;~SíYùäiN€NÈ8îoÅ_ÿ/™Ë£ÚÓ@¦"³m ?7l‹•àÓó×v˜=íÍùºÏ»Ì>Ã\FQ¶ÑÏ3ù®6ˆlı$o“)êvœ†&™±ø.Ì°ˆ»t·0\WPÑê?^§RAKÿ`¥|ÃaÉğìÂ^¸)DùÑç8ğSK¶>j(G”2Ü"Wz¸~$fİ¶E¯ Z	®³L_ë¹(Za+©œm òÏƒ¹;å=*sÇé˜§ëW'_ò×ëçı¦Wf*­„$¼±Éµ¨—0ß\Rÿ5’Ëá9F,D×®ÚÁ ~˜Ûğ÷P?ÖRnã¤$­@D„º$üla¦2ş „<ƒ÷,Í5±¥Th¤}?o AíğécY;Ø½šn©·ºø„%E—#)È‹g·÷6Än ™mê‡ßHåº»"yÙqçaÆµ£0É=)–ÛAÅ`?¼¯\¾¿ñ<D•¾Œ-İ&|úJ–9c'Ym×¡ĞGjà_ÒRÔã—a37ëeX%tĞ‡5¸§jjÜ¤î#Éš+İà|8‚&§üØ»İˆ£äg%±­bÊû
Á%&O«›¥•ŞXP)‡vü‘;NúÎyFºÒf‘rÍdrB’è4Àl¿:RWuoc0¦zãE¼g1Ş{ö×}ŞÎ—<Ëó½U²UÍä¡m8ÁºY#È‚j€Ç†æ&$¾NŒ+ç¸ø–AËÁà˜\O+`.w0!&~+ÕF¼T®wDÑÌ•š"^¢û™†Ëÿ*Q€Œ ¨5”eha	6hı­ELù–D´ÁBKMÌÕe>¤]	Isn úÒ3?»{ÿîAó€W"(VãfÇ§ænÍ›&6ï{®q5XÁÁ~Ğ‡aó³ì’¸ëêzò‡ºš‹›à'oÑm2bÕĞ‡ŠÆhYZ™	!ú%£êeö³U`ö»h ö›ÙaÆ3Òt˜.î_°kHĞOpÇŠı©«X<Òß*àâÊF†á
ÔgEŸælwÈºm=¾±È|HÄ0ó×ÿoµĞê‘ Áï_ã*;×Ü71ÿW§^Š­{E›,“q´go¹¿áò
’ôø¦!ÀÍ‹lKäküÆÅ˜å)oøô3gĞá~­–Åèm(AøEvXà]è¢¬³sIBŞÚ»CJÔ- ;Br2ø¨â¨Ú`oA îŒuúF*¥'”Û¢¨]>”+xekéw™jp^æà7®µÚ_öÔx’ÕaC{4!jÊ>årİ(dU”i³£YE²‰òlàç`ß§A_{O Ş>:Ì$R´k›¬8”IDóî¼}·	Ú'®zs-„£¿!ó?à—3Şá¥ô.(§b!˜šISh‡N|dèİıP«Âå';u¸['‹¼éMÂøÀçÎí:tÙMÉèéİ•ÿL‘÷aì¥ÈfÆ+f§oQQgZ .SJÉÕî+BC‹
[ïB±uÊ–íÁ§ÃÌ€Tğ¼*ÿvÌ#<—'”ò'T?JFèİÊ®'ºÖ>£Á§X%pí2";©—lIÓ~7„bız¦ı´‘0#ÉE8 •&ª¬±»ƒ‚°2ş1£+{sIf{&Şëğ‰ÊÆUÒ=`µQ\7îÛG'™Cùª»(¤åb–!g&9sŠ<t²` ;;MUörKáŠÌ¸GK<Îö7Æ2'Æ2ŒhìbAhò¦ õmƒ®ş1u’ØQ¬´˜„¾/‡ûÍZÛ%HK¾Iø*@Eûûmsª‘¡ZÆXAgó×—0pÏ–."h"EğäHd ‹Ä¢|¥ÄV71ò“_Ó0BÜW°ëÈ¡‘îFzXf¬#àÒ–
¨¡Óy*xæ2Ë~6ß.1 •œƒ+X_¾½ßiÄ6…Î[ªıÁ›€Æ‹¦IûF=Õ:ûbdıï|ï­±ísM0àüyÛ¼ôfAƒÕ1üt@ûß^)û›2.Êclñ*¹KO• :à<›Ù	Íì¹Ëlr5ÒwTrAMÑqzxŞå§Ò8€?¤ùVÇ|İ8Ô™2ÈDÓúÓ´½íæÿŒn°–£¹W<uQ&‘Â%¸]Ş;¾yådOÙ†(p÷©Îÿ12UeÆAy!Ê;†Û]Æ×#aƒi¹Ûeñ=‰[eO¦ jT"^	ó+Â1W†à™ëe<wßCşÇ'Šöü(¿<Aråœh¾’OØß>¿˜–531‡S¡NĞ‡¥ÆJ:ƒFÍ¾Ç45İS¿ºR9Ë{p)ñÈ2<R
Oä¨4¨0—~•¢í|•pÄñÔÿ Á9¬}ï Hd™a·tÌÑFfFD‚w T’–>N»¸âÛ2Q§ëWGbÊpGAR¶æW†’Væ­g|›h´„6¦“aşÏléÆFÄƒpu#Fj€”x­j©ˆî[4›Ği97ámE/
?9—°x÷Çà¡Ar,b¡F×1f—<ßg×!Ë2ìîeu“ñœCı6±Îf_†YĞ¯[»ò/nL•Û¦éaÀå—™!añÆh°ß[æy_1¶•uó~‘w
2ßüš’/tæ‡b‚4®v¯µï¡íLwõ°‘àhÓ}‰rşv¦-ù.Ê¿Q%ğˆ„·5,µ!Ñl8šeÆš©¦&Ôw3ãC‰æMØ‹óÇãøé.ş­l-¯ıtÛÍ2¨~ŒP­™^Ó‘WìkyJ¸:˜_oIK6Ğaÿ1]ÕnşğN%şfeØ<7hMñö’z’*.¡à!øö³/ƒe¦ÖÏ-D°&™p.[ÜHrTg4Ù}³UòìiˆC(V³4öÕ)×–}ÍÒkùq7y¨Ñ´ıÂ/Â“”>ÈŸÄ/ Ş,ğ°¼\âeŞgÙh{Ê×Hˆ ïş3œšá*SMˆş§x¥?€tÁ)xÂ6Ï7w*Ûlçx,@úN¼9Ğ²au\(&¿ÏğùNú`K#o_ùÂúòÓ¬Mİ#³!T6z*‡+–°©|ÈDÁRC©Õšjöñ8Ğp“şÄÇ›#›´÷İBü4†šã—ß ¡æšq ñR_°‹âDˆÍ­ÛzëpcÌ3Jm3ÆÒäzÓSö/¶f¼°X¯hãuzÈIkïÀ"†vnÚ‘²´*È×¬èMï2>ƒ%(—a¹Ø‘ÌäÆŠPV@¡ªö“ªE©¨S¯ç“g¦$EÖBãI´Œà÷ h.m¹;¨)‡alaOù-GÄô)Pv2È¯@B¬ÎKŞŞf1íñÕæœ¾|t¼|K±_)¬+¿d*0Û-«²vhËóAh²óÅ µªøl˜ä^ 5~E3ÈuÍ/£á¨
õ³ı¼‘Zîã5JÂ¬NöæÒccÏº¾ÓB:£ÚáL³˜™ 
I~Õ¼ïƒ[O«˜¹zù~·NÄ¶p£Gc1²ƒÖJ¶ıÂÿÊÎ a‘6òWQqC·Õ²»şé°©[­ŠxŞa¡&Ğµ)ºËôÒËEN~‹ÌÄæ˜“+Ãé§0&£ìÏÑ)óå×óyXx fkº…§Ş·.©LÌà"éZ³ÌğY02Dî>øÅ=``ßv
ñğb^âÎïİ¶b~£É<Üı¹ƒÉsiéOIA¢š¼Úó3İßOŒĞõÂ0Q
Obô,Lº´ş¹ÂoM2ò¦÷2C¼ÌÍñ°/nk>ö‰³2®¸(¿XU@K´ì¸ ›Sÿ{¼ÒT~’[NjÄ““œgKøkÜ™µ8	2b*,>«Ò(º¤!ÔÕ`a™ä¤ó-µI’:\Ğ@.ÔØ$çÃ i›±D‹¹}ò ÷l=.Zæ+)	=–Ì±¤mJ©te+‚é^°êJ%”ßtçç>õúÖeN b	¬@?Lrí8Í¨éŒé•ÒàÉ ê‘ØÜ4ó=ê×ò…ğÓØüù=4ª¤ƒ1ôFÇ4ø¡e›^üğû'-Øç<¯Pf=ğŞ&,ş„—\VüV‹–ãäŞuP¿—ß€öNàş¯aÑußHÇñğ×Ûe¬.¥ğ< Ğ#
¼ÜlÜ“Ÿ Î! š·KOA9Ÿ²ní¹Işù´ÄQõÎÂY©Ìæëh»qûŠ¡Û1(Á!Á¦##ˆ¡Ú•š`v,ıÉ„ZÆÚ|{LšÉ¶ê {ht!ˆ¢—óM"’Z{ËÿİN+ÃÔ^ÏşêÊ yÇ;~\`È©­Åcmx«*c,”k.Û¶[8n¢½ì¹î´·;‰iü ‘,T–bÅC‘µw^®WHÏkJëK[r%Át•ÇË1kŸÕ)ò7·º,Vºà©p°OK2i»øí4=¬$h’%µû ì;cY*äˆîú»=.ìR£lY$‘=µQgVËôñ‚´x'%w}f\2ı‚ªŒ´ÇÀNëts±ûä àº}…ôˆÏf=»búıå".ùX‹ìZóŞt¿h€s‹†ãY‰"gn™øÒ’v³¼^ïOëyİ'(ÎÎô\M¥ØÅ LãZĞïÿ›™á¼å&XéØóøßø^¶ÇÔ
ØØ6ìmà|JŠìR
óŠöÈ–ßóâã¡ª(\Á‹¦1u9#L6•
îşl–í$6ü?ª{20q‚ƒB6ˆÆÂ;„?¦Ö$UµTN`Ïbå.’-ğnª:[î¶ìb0ª©+qÑÎ<ÒAÔÄ¢?õÕ^­_`|ÿ"t¡ç€£Ê›¬
FÏÛ.‡NÆÜ*hî‰‰×üı€Š@@GQ“Iw•$Õ= [&âó’¡<µx ¼ª™`"«ps,ÁÙ£ÉÈN¶¯€K¤IËq'ÌXM“HÂezİ8OöP4ºã%uoŸ‹ÔGë+ø,|^‚iùCü?"¾õÂ×İµØJ·B„Èì©®E(¨.Åhº-?…ÃÁ“:Ä'ùA$w@ŞïÖ’ºÕäIĞcJ:^ËCÔâ?Öáöµ‹}&¨òIZÀ`Y“Æ¬X¾WÃŸÆ8%Áï}P
‹¬|á[/+3ŞCD§HÓ:Â{#
F»ÏŠs_Ï÷¯tù ÉÁxõö^—qG2t]×Š=hÃş']³nÓÿ	ÂA_÷»åãª”G*É«ß©+šßØåÚ>ç<¼(æP›Ê‘y­ÕÆ ï~KŸËUjNE‹ÆSs;Q2EÊÅÒ§õÆº¼‹ym6D;½Mî±çò¢ŸŸÅw\òØvõè%`;:T„µÈŒè= ØBËÍÀ¤+ĞTÙ:*²’‰ª¢•7rÊ º^®Ğ[¯±†ó/Á5H¼ˆ¥Wi1ÇØĞÛ“ˆ)h—G¡ñîZqäRëàÁL.˜¬­Õ9tÇ—1©­~Dbâ`zCUõôô1…«üÍëx6Zæš ç6¨˜Û’"5+RîâÅøÃ¨Z<¯Š¡İL;‡‚“î²4p                    commands = commands.get('python.commands')
                        except Exception:
                            logger.warning('Unable to read JSON metadata, so '
                                           'cannot generate scripts')
                    if commands:
                        console_scripts = commands.get('wrap_console', {})
                        gui_scripts = commands.get('wrap_gui', {})
                        if console_scripts or gui_scripts:
                            script_dir = paths.get('scripts', '')
                            if not os.path.isdir(script_dir):
                                raise ValueError('Valid script path not '
                                                 'specified')
                            maker.target_dir = script_dir
                            for k, v in console_scripts.items():
                                script = '%s = %s' % (k, v)
                                filenames = maker.make(script)
                                fileop.set_executable_mode(filenames)

                            if gui_scripts:
                                options = {'gui': True }
                                for k, v in gui_scripts.items():
                                    script = '%s = %s' % (k, v)
                                    filenames = maker.make(script, options)
                                    fileop.set_executable_mode(filenames)

                    p = os.path.join(libdir, info_dir)
                    dist = InstalledDistribution(p)

                    # Write SHARED
                    paths = dict(paths)     # don't change passed in dict
                    del paths['purelib']
                    del paths['platlib']
                    paths['lib'] = libdir
                    p = dist.write_shared_locations(paths, dry_run)
                    if p:
                        outfiles.append(p)

                    # Write RECORD
                    dist.write_installed_files(outfiles, paths['prefix'],
                                               dry_run)
                return dist
            except Exception:  # pragma: no cover
                logger.exception('installation failed.')
                fileop.rollback()
                raise
            finally:
                shutil.rmtree(workdir)

    def _get_dylib_cache(self):
        global cache
        if cache is None:
            # Use native string to avoid issues on 2.x: see Python #20140.
            base = os.path.join(get_cache_base(), str('dylib-cache'),
                                '%s.%s' % sys.version_info[:2])
            cache = Cache(base)
        return cache

    def _get_extensions(self):
        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        arcname = posixpath.join(info_dir, 'EXTENSIONS')
        wrapper = codecs.getreader('utf-8')
        result = []
        with ZipFile(pathname, 'r') as zf:
            try:
                with zf.open(arcname) as bf:
                    wf = wrapper(bf)
                    extensions = json.load(wf)
                    cache = self._get_dylib_cache()
                    prefix = cache.prefix_to_dir(pathname)
                    cache_base = os.path.join(cache.base, prefix)
                    if not os.path.isdir(cache_base):
                        os.makedirs(cache_base)
                    for name, relpath in extensions.items():
                        dest = os.path.join(cache_base, convert_path(relpath))
                        if not os.path.exists(dest):
                            extract = True
                        else:
                            file_time = os.stat(dest).st_mtime
                            file_time = datetime.datetime.fromtimestamp(file_time)
                            info = zf.getinfo(relpath)
                            wheel_time = datetime.datetime(*info.date_time)
                            extract = wheel_time > file_time
                        if extract:
                            zf.extract(relpath, cache_base)
                        result.append((name, dest))
            except KeyError:
                pass
        return result

    def is_compatible(self):
        """
        Determine if a wheel is compatible with the running system.
        """
        return is_compatible(self)

    def is_mountable(self):
        """
        Determine if a wheel is asserted as mountable by its metadata.
        """
        return True # for now - metadata details TBD

    def mount(self, append=False):
        pathname = os.path.abspath(os.path.join(self.dirname, self.filename))
        if not self.is_compatible():
            msg = 'Wheel %s not compatible with this Python.' % pathname
            raise DistlibException(msg)
        if not self.is_mountable():
            msg = 'Wheel %s is marked as not mountable.' % pathname
            raise DistlibException(msg)
        if pathname in sys.path:
            logger.debug('%s already in path', pathname)
        else:
            if append:
                sys.path.append(pathname)
            else:
                sys.path.insert(0, pathname)
            extensions = self._get_extensions()
            if extensions:
                if _hook not in sys.meta_path:
                    sys.meta_path.append(_hook)
                _hook.add(pathname, extensions)

    def unmount(self):
        pathname = os.path.abspath(os.path.join(self.dirname, self.filename))
        if pathname not in sys.path:
            logger.debug('%s not in path', pathname)
        else:
            sys.path.remove(pathname)
            if pathname in _hook.impure_wheels:
                _hook.remove(pathname)
            if not _hook.impure_wheels:
                if _hook in sys.meta_path:
                    sys.meta_path.remove(_hook)

    def verify(self):
        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        data_dir = '%s.data' % name_ver
        info_dir = '%s.dist-info' % name_ver

        metadata_name = posixpath.join(info_dir, METADATA_FILENAME)
        wheel_metadata_name = posixpath.join(info_dir, 'WHEEL')
        record_name = posixpath.join(info_dir, 'RECORD')

        wrapper = codecs.getreader('utf-8')

        with ZipFile(pathname, 'r') as zf:
            with zf.open(wheel_metadata_name) as bwf:
                wf = wrapper(bwf)
                message = message_from_file(wf)
            wv = message['Wheel-Version'].split('.', 1)
            file_version = tuple([int(i) for i in wv])
            # TODO version verification

            records = {}
            with zf.open(record_name) as bf:
                with CSVReader(stream=bf) as reader:
                    for row in reader:
                        p = row[0]
                        records[p] = row

            for zinfo in zf.infolist():
                arcname = zinfo.filename
                if isinstance(arcname, text_type):
                    u_arcname = arcname
                else:
                    u_arcname = arcname.decode('utf-8')
                # See issue #115: some wheels have .. in their entries, but
                # in the filename ... e.g. __main__..py ! So the check is
                # updated to look for .. in the directory portions
                p = u_arcname.split('/')
                if '..' in p:
                    raise DistlibException('invalid entry in '
                                           'wheel: %r' % u_arcname)

                if self.skip_entry(u_arcname):
                    continue
                row = records[u_arcname]
                if row[2] and str(zinfo.file_size) != row[2]:
                    raise DistlibException('size mismatch for '
                                           '%s' % u_arcname)
                if row[1]:
                    kind, value = row[1].split('=', 1)
                    with zf.open(arcname) as bf:
                        data = bf.read()
                    _, digest = self.get_hash(data, kind)
                    if digest != value:
                        raise DistlibException('digest mismatch for '
                                               '%s' % arcname)

    def update(self, modifier, dest_dir=None, **kwargs):
        """
        Update the contents of a wheel in a generic way. The modifier should
        be a callable which expects a dictionary argument: its keys are
        archive-entry paths, and its values are absolute filesystem paths
        where the contents the corresponding archive entries can be found. The
        modifier is free to change the contents of the files pointed to, add
        new entries and remove entries, before returning. This method will
        extract the entire contents of the wheel to a temporary location, call
        the modifier, and then use the passed (and possibly updated)
        dictionary to write a new wheel. If ``dest_dir`` is specified, the new
        wheel is written there -- otherwise, the original wheel is overwritten.

        The modifier should return True if it updated the wheel, else False.
        This method returns the same value the modifier returns.
        """

        def get_version(path_map, info_dir):
            version = path = None
            key = '%s/%s' % (info_dir, METADATA_FILENAME)
            if key not in path_map:
                key = '%s/PKG-INFO' % info_dir
            if key in path_map:
                path = path_map[key]
                version = Metadata(path=path).version
            return version, path

        def update_version(version, path):
            updated = None
            try:
                v = NormalizedVersion(version)
                i = version.find('-')
                if i < 0:
                    updated = '%s+1' % version
                else:
                    parts = [int(s) for s in version[i + 1:].split('.')]
                    parts[-1] += 1
                    updated = '%s+%s' % (version[:i],
                                         '.'.join(str(i) for i in parts))
            except UnsupportedVersionError:
                logger.debug('Cannot update non-compliant (PEP-440) '
                             'version %r', version)
            if updated:
                md = Metadata(path=path)
                md.version = updated
                legacy = not path.endswith(METADATA_FILENAME)
                md.write(path=path, legacy=legacy)
                logger.debug('Version updated from %r to %r', version,
                             updated)

        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        record_name = posixpath.join(info_dir, 'RECORD')
        with tempdir() as workdir:
            with ZipFile(pathname, 'r') as zf:
                path_map = {}
                for zinfo in zf.infolist():
                    arcname = zinfo.filename
                    if isinstance(arcname, text_type):
                        u_arcname = arcname
                    else:
                        u_arcname = arcname.decode('utf-8')
                    if u_arcname == record_name:
                        continue
                    if '..' in u_arcname:
                        raise DistlibException('invalid entry in '
                                               'wheel: %r' % u_arcname)
                    zf.extract(zinfo, workdir)
                    path = os.path.join(workdir, convert_path(u_arcname))
                    path_map[u_arcname] = path

            # Remember the version.
            original_version, _ = get_version(path_map, info_dir)
            # Files extracted. Call the modifier.
            modified = modifier(path_map, **kwargs)
            if modified:
                # Something changed - need to build a new wheel.
                current_version, path = get_version(path_map, info_dir)
                if current_version and (current_version == original_version):
                    # Add or update local version to signify changes.
                    update_version(current_version, path)
                # Decide where the new wheel goes.
                if dest_dir is None:
                    fd, newpath = tempfile.mkstemp(suffix='.whl',
                                                   prefix='wheel-update-',
                                                   dir=workdir)
                    os.close(fd)
                else:
                    if not os.path.isdir(dest_dir):
                        raise DistlibException('Not a directory: %r' % dest_dir)
                    newpath = os.path.join(dest_dir, self.filename)
                archive_paths = list(path_map.items())
                distinfo = os.path.join(workdir, info_dir)
                info = distinfo, info_dir
                self.write_records(info, workdir, archive_paths)
                self.build_zip(newpath, archive_paths)
                if dest_dir is None:
                    shutil.copyfile(newpath, pathname)
        return modified

def compatible_tags():
    """
    Return (pyver, abi, arch) tuples compatible with this Python.
    """
    versions = [VER_SUFFIX]
    major = VER_SUFFIX[0]
    for minor in range(sys.version_info[1] - 1, - 1, -1):
        versions.append(''.join([major, str(minor)]))

    abis = []
    for suffix, _, _ in imp.get_suffixes():
        if suffix.startswith('.abi'):
            abis.append(suffix.split('.', 2)[1])
    abis.sort()
    if ABI != 'none':
        abis.insert(0, ABI)
    abis.append('none')
    result = []

    arches = [ARCH]
    if sys.platform == 'darwin':
        m = re.match(r'(\w+)_(\d+)_(\d+)_(\w+)$', ARCH)
        if m:
            name, major, minor, arch = m.groups()
            minor = int(minor)
            matches = [arch]
            if arch in ('i386', 'ppc'):
                matches.append('fat')
            if arch in ('i386', 'ppc', 'x86_64'):
                matches.append('fat3')
            if arch in ('ppc64', 'x86_64'):
                matches.append('fat64')
            if arch in ('i386', 'x86_64'):
                matches.append('intel')
            if arch in ('i386', 'x86_64', 'intel', 'ppc', 'ppc64'):
                matches.append('universal')
            while minor >= 0:
                for match in matches:
                    s = '%s_%s_%s_%s' % (name, major, minor, match)
                    if s != ARCH:   # already there
                        arches.append(s)
                minor -= 1

    # Most specific - our Python version, ABI and arch
    for abi in abis:
        for arch in arches:
            result.append((''.join((IMP_PREFIX, versions[0])), abi, arch))

    # where no ABI / arch dependency, but IMP_PREFIX dependency
    for i, version in enumerate(versions):
        result.append((''.join((IMP_PREFIX, version)), 'none', 'any'))
        if i == 0:
            result.append((''.join((IMP_PREFIX, version[0])), 'none', 'any'))

    # no IMP_PREFIX, ABI or arch dependency
    for i, version in enumerate(versions):
        result.append((''.join(('py', version)), 'none', 'any'))
        if i == 0:
            result.append((''.join(('py', version[0])), 'none', 'any'))
    return set(result)


COMPATIBLE_TAGS = compatible_tags()

del compatible_tags


def is_compatible(wheel, tags=None):
    if not isinstance(wheel, Wheel):
        wheel = Wheel(wheel)    # assume it's a filename
    result = False
    if tags is None:
        tags = COMPATIBLE_TAGS
    for ver, abi, arch in tags:
        if ver in wheel.pyver and abi in wheel.abi and arch in wheel.arch:
            result = True
            break
    return result
