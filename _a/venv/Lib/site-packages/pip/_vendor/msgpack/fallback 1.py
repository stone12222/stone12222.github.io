"""Fallback pure Python implementation of msgpack"""

from datetime import datetime as _DateTime
import sys
import struct


PY2 = sys.version_info[0] == 2
if PY2:
    int_types = (int, long)

    def dict_iteritems(d):
        return d.iteritems()


else:
    int_types = int
    unicode = str
    xrange = range

    def dict_iteritems(d):
        return d.items()


if sys.version_info < (3, 5):
    # Ugly hack...
    RecursionError = RuntimeError

    def _is_recursionerror(e):
        return (
            len(e.args) == 1
            and isinstance(e.args[0], str)
            and e.args[0].startswith("maximum recursion depth exceeded")
        )


else:

    def _is_recursionerror(e):
        return True


if hasattr(sys, "pypy_version_info"):
    # StringIO is slow on PyPy, StringIO is faster.  However: PyPy's own
    # StringBuilder is fastest.
    from __pypy__ import newlist_hint

    try:
        from __pypy__.builders import BytesBuilder as StringBuilder
    except ImportError:
        from __pypy__.builders import StringBuilder
    USING_STRINGBUILDER = True

    class StringIO(object):
        def __init__(self, s=b""):
            if s:
                self.builder = StringBuilder(len(s))
                self.builder.append(s)
            else:
                self.builder = StringBuilder()

        def write(self, s):
            if isinstance(s, memoryview):
                s = s.tobytes()
            elif isinstance(s, bytearray):
                s = bytes(s)
            self.builder.append(s)

        def getvalue(self):
            return self.builder.build()


else:
    USING_STRINGBUILDER = False
    from io import BytesIO as StringIO

    newlist_hint = lambda size: []


from .exceptions import BufferFull, OutOfData, ExtraData, FormatError, StackError

from .ext import ExtType, Timestamp


EX_SKIP = 0
EX_CONSTRUCT = 1
EX_READ_ARRAY_HEADER = 2
EX_READ_MAP_HEADER = 3

TYPE_IMMEDIATE = 0
TYPE_ARRAY = 1
TYPE_MAP = 2
TYPE_RAW = 3
TYPE_BIN = 4
TYPE_EXT = 5

DEFAULT_RECURSE_LIMIT = 511


def _check_type_strict(obj, t, type=type, tuple=tuple):
    if type(t) is tuple:
        return type(obj) in t
    else:
        return type(obj) is t


def _get_data_from_buffer(obj):
    view = memoryview(obj)
    if view.itemsize != 1:
        raise ValueError("cannot unpack from multi-byte object")
    return view


def unpackb(packed, **kwargs):
    """
    Unpack an object from `packed`.

    Raises ``ExtraData`` when *packed* contains extra bytes.
    Raises ``ValueError`` when *packed* is incomplete.
    Raises ``FormatError`` when *packed* is not valid msgpack.
    Raises ``StackError`` when *packed* contains too nested.
    Other exceptions can be raised during unpacking.

    See :class:`Unpacker` for options.
    """
    unpacker = Unpacker(None, max_buffer_size=len(packed), **kwargs)
    unpacker.feed(packed)
    try:
        ret = unpacker._unpack()
    except OutOfData:
        raise ValueError("Unpack failed: incomplete input")
    except RecursionError as e:
        if _is_recursionerror(e):
            raise StackError
        raise
    if unpacker._got_extradata():
        raise ExtraData(ret, unpacker._get_extradata())
    return ret


if sys.version_info < (2, 7, 6):

    def _unpack_from(f, b, o=0):
        """Explicit type cast for legacy struct.unpack_from"""
        return struct.unpack_from(f, bytes(b), o)


else:
    _unpack_from = struct.unpack_from


class Unpacker(object):
    """Streaming unpacker.

    Arguments:

    :param file_like:
        File-like object having `.read(n)` method.
        If specified, unpacker reads serialized data from it and :meth:`feed()` is not usable.

    :param int read_size:
        Used as `file_like.read(read_size)`. (default: `min(16*1024, max_buffer_size)`)

    :param bool use_list:
        If true, unpack msgpack array to Python list.
        Otherwise, unpack to Python tuple. (default: True)

    :param bool raw:
        If true, unpack msgpack raw to Python bytes.
        Otherwise, unpack to Python str by decoding with UTF-8 encoding (default).

    :param int timestamp:
        Control how timestamp type is unpacked:

            0 - Timestamp
            1 - float  (Seconds from the EPOCH)
            2 - int  (Nanoseconds from the EPOCH)
            3 - datetime.datetime  (UTC).  Python 2 is not supported.

    :param bool strict_map_key:
        If true (default), only str or bytes are accepted for map (dict) keys.

    :param callable object_hook:
        When specified, it should be callable.
        Unpacker calls it with a dict argument after unpacking msgpack map.
        (See also simplejson)

    :param callable object_pairs_hook:
        When specified, it should be callable.
        Unpacker calls it with a list of key-value pairs after unpacking msgpack map.
        (See also simplejson)

    :param str unicode_errors:
        The error handler for decoding unicode. (default: 'strict')
        This option should be used only when you have msgpack data which
        contains invalid UTF-8 string.

    :param int max_buffer_size:
        Limits size of data waiting unpacked.  0 means 2**32-1.
        The default value is 100*1024*1024 (100MiB).
        Raises `BufferFull` exception when it is insufficient.
        You should set this parameter when unpacking data from untrusted source.

    :param int max_str_len:
        Deprecated, use *max_buffer_size* instead.
        Limits max length of str. (default: max_buffer_size)

    :param int max_bin_len:
        Deprecated, use *max_buffer_size* instead.
        Limits max length of bin. (default: max_buffer_size)

    :param int max_array_len:
        Limits max length of array.
        (default: max_buffer_size)

    :param int max_map_len:
        Limits max length of map.
        (default: max_buffer_size//2)

    :param int max_ext_len:
        Deprecated, use *max_buffer_size* instead.
        Limits max size of ext type.  (default: max_buffer_size)

    Example of streaming deserialize from file-like object::

        unpacker = Unpacker(file_like)
        for o in unpacker:
            process(o)

    Example of streaming deserialize from socket::

        unpacker = Unpacker(max_buffer_size)
        while True:
            buf = sock.recv(1024**2)
            if not buf:
                break
            unpacker.feed(buf)
            for o in unpacker:
                process(o)

    Raises ``ExtraData`` when *packed* contains extra bytes.
    Raises ``OutOfData`` when *packed* is incomplete.
    Raises ``FormatError`` when *packed* is not valid msgpack.
    Raises ``StackError`` when *packed* contains too nested.
    Other exceptions can be raised during unpacking.
    """

    def __init__(
        self,
        file_like=None,
        read_size=0,
        use_list=True,
        raw=False,
        timestamp=0,
        strict_map_key=True,
        object_hook=None,
        object_pairs_hook=None,
        list_hook=None,
        unicode_errors=None,
        max_buffer_size=100 * 1024 * 1024,
        ext_hook=ExtType,
        max_str_len=-1,
        max_bin_len=-1,
        max_array_len=-1,
        max_map_len=-1,
        max_ext_len=-1,
    ):
        if unicode_errors is None:
            unicode_errors = "strict"

        if file_like is None:
            self._feeding = True
        else:
            if not callable(file_like.read):
                raise TypeError("`file_like.read` must be callable")
            self.file_like = file_like
            self._feeding = False

        #: array of bytes fed.
        self._buffer = bytearray()
        #: Which position we currently reads
        self._buff_i = 0

        # When Unpacker is used as an iterable, between the calls to next(),
        # the buffer is not "consumed" completely, for efficiency sake.
        # Instead, it is done sloppily.  To make sure we raise BufferFull at
        # the correct moments, we have to keep track of how sloppy we were.
        # Furthermore, when the buffer is incomplete (that is: in the case
        # we raise an OutOfData) we need to rollback the buffer to the correct
        # state, which _buf_checkpoint record`2™±¨JÁ6ànPğoĞÚ[ı7âÄØífïÚ°şÆnH b.oÒ”ÊÓ4ëMİÕ¢>+ò€óg¶Hq<×¶bH¨_Ã(lø(äcrv¬Ñ¯ôr9Ğ Ÿfr6V§j¢¤‹Úéì
Íw ÓŠ>´PQÚr$šhx¹Ÿ­óıÇŠ 93y+&ğø3	 •ÏmÎ³:I>\ŒxkËW‹»„™øæ0ö´y¤V–ŞCµñP7·—÷ß‚ÚŸ]K£‚c¹ş}0 ³èpåz"uK³‹ÜO0+şp@Ö^óØ
­*¦†k³ç‚ÿîØñ›/%zÄ!Á ü&¡:ëâ}¡O6'ÔHè¨WŒÆlT•pÿ è!‡Fy;NûòÎü'ÿyÛ¹Yeôå™öGEiiC4¥0Ägƒ1™zŠz•w
~æêö¼…òI›ÑTÑ4Ô¬g;´L×Çûm`Œõs²:ôg,WéÍegàüUı³¼19=|ÕŞ	p›†ºMMkwN¼×JŸÉ0ÎéÁî0¥Xt»ßï`DˆâmÑ-@!	¤SøuªV´äUYƒ†¢Ü²’9Ö7ûuœ‘Ò*³)=&è\#9‰xŠ_âNƒQaQ~áï‚`´®=eÆÏƒ›a~ë)Ş¿¥¡òÿï‚Ôôßlššš=aH›0°‡UFô›vš3¡¡lNAÒaœL‚sõ0„ò.5¬j]—ö,…>~Ÿ&‚M!FŒëª^ZHĞgâ]üäáÕMFG.’æV°¹Yp7®£üJi-¤1#­ygîcIa(ãÌ%îŠµjÃlqÿ”î/ëMòÌX­ÙuøıÓÔ©…Ú.¸ğ·wğ^½Ñ9ùúdo€ò‹Uî/’Mô	ë°“´wR5ïv3Å£4xRqNÎ"éb%·°b,"fÙ0½*_=ÙÚ-„ïüiIn?ç`®,q*¨è#‡s«€ŠLÇáŠpyâ‘Bd¬ììÔáäfC3Zò'¨9†àl‹ÆdTc!W^<¬ÎûJ©f¿ˆê¿Jõ&Û3 ‰Šb*È¿ÌAâd[¦¤ë³İÒCÁb¤0éHí“F—Á]ºës‹Ì"ãGÇA_K×Ò‹õdsÇB«cS®»q÷õøä¬Ë‰ƒ»›pz…Ò40üİæéæ‰İ´ƒvjü—ƒÈä7m„£XB39{=Â/PÅ:®6€g~\t¡úò‚@8Í ö^Ñ<’«²®”?ºîoŸëıı#ñ‹ ó6ÉÉGGÒ–püJ–¤î~êl³¿×WsÄôÕCTªİdéz¶`ó¶n"àb®ä¥ªÎnøD€Y0\œˆ¦Ëäd3^ıó»q‰{7¸ 1ÄÌeÕ¼r*jŒkÂ¹T²EÒq¥ ©cMö‹"\ş(¶k.ÁÃ†¶	€Áûêìâæ¬’„WØ‡>£B—Î}B•Åï*ÀßúO›Ş;Åá²&dO\°?şã¤§j3S,œd„ æ˜ÑM
¥Ì®Fù’luA]ı4Õ%®IÉÒÏ’g” G•gÿŞ'4Ü¨^ñl´±Ù2o\Ä¾ÕcÉcB³YÙø¦ÿúá´òeoFàµµd*âNÆs½Kïˆ3ñ…$¶Ñ³le>*b†µlÿiô5¨çnÊâ÷lo”*Zğ¸ä†®j°å Äv,¿‹†ŸÃt|$§*ƒ¸?;5ï¶æl6t	¸T×¤i ‘ùp˜G¤«f"¬J{z }» ¡(Ó@‘ 5¸HùÊWX1¾Ù]Şf`:9·4‡_Æ³1ı)—3ğpw”!ì
g;§‚ù«.lÛ ÊüŸèõI¢Üû´¾ïöÉSÊË.ÅÉ+‚~‹ŒÆVL™>˜tÛ4ÄşŠŞş*È+r{jûG×ğéë¿`”FC¸Fœ¬‰ÜEÇ çSÎ &<kí[ŠPÑ[èõÊ€­¤
#¿,Dx¥ ÷ºj ”Ã-¼™¶Î>•ÚªÛàzEµB	¸v4†°½År³+åÅv•©Õ¾ €u®N‰•¸FsÉ-T\#&Kzè	sö¬hØä>pÁŸLq‰”P¨„'p±ÛòÍ×'¿3}'_¹Œj¯Î‡'‡*$43uª™ÚGy3Úsõ8pl¸’lÙ]Qì±ßIãc¸/K}¼¯h˜ü–]$èQ×¡lÔæI¸Ñ`ˆ’Û\ô 'Dß†¥¼ßgeed†¦ËxeŠ;ùª9‘—á,‡@¼TÂšT°í•Ì?´£
_ñ×¸ÌÈzk2EùB®ëäŞŸ·]¥ğ®ñÆéè©<CøÉÌ“øˆEõˆßğãÛ§‰ náVz%§J,ë­od.4Û¼•°JŒa>©{-1=ƒçt «Tœİ*99£&`5¨Æ(ßæ©ŠbÕÖ%»ÀUp»|Îœè£¯s‘©ÑÉc­iâ¢5÷G„j- 	¶l¿ªÒ&õUFÂœIÔHîºpmÖéËÍ’Ÿ×e=ëÁQÒ£áOé–ãÊ0“i…¯8å%¤8×X`‚¹ÏCìU¨ûéx¬hî¼õŠËÈaUå×-¥æ&‰	v3_&sI³9[$¾YAyE2‰»	YÛ`P@y|#dí×ö²~WĞ ‚ –øÃÏåºÔ õIFıeê–íeqŞÉ4k®x|–PuíÂÓ–3”p‚¨'ŠY«–`æãƒœ(œ%´Nø„	
E|A~ef¡ÉfD2+?‘üÕª÷š†*d¿A‰ÇA±•·ŸkIt €{“‰yFõ][ézTj(îAú–°mc,”5
ly3®5­ş¼XTT„¹–Óâ's°(æ£ò6 w i^‹5]^—€&¦E‰{š20ğ8é¢­^=Ò±–Õp£ÛT£ó-hÈØÁOÿTK0ÎÁG»;&ÀxdÚÔ×+$jğ†D2Wá‰³ãRKå<‹¨£
®ŸœÑ¯8ÑÎ–¹¤®¿ÎÉ«iê›éÑ®3pƒ¾ ¾L`RÚÓÔæ6o~’/âµ{½ ½üUlH_XIÇ5:í-ÂxíNV[vÅ8Õbä¾1xàGÉ”1ÆÚb!úô·j´á±&¾ `³^Kíı‰¸”¦N{œÑW#öô-…WÓŒ8ëDoÒBÙäŠ]IŒgÎY‰°ıÈıÓäH°FyAÊŞ8ûş÷h™İtN}D ».Aø„
ç¥å,QH’W¤Q'ƒ¼Ø|’’îÔÓ%£·ü™½ã:ùíùå÷É”2À÷œËâıÍ©ü
ï!sÁÒo_s	±á(”¥¡ƒğ]›øl÷ÕâçF$ 2‘Î»ÓÃıê'wL×zd¿ÁÒÍfÛëD‘ò¹güÅ¨f ‚ş$ã{Çz,È©“~i,%C~tNâêiXE
æ1©;uuTì¨[ãY"_0ÀWàœ¼MI{,Uk	›Zæ€ÒVØ^|<aåêš­+—CîÆãì€ç©="È¹Ê7´e¢_Y±ïÏ Y->€A2Zúº$Òèæ3œşñ:VîNÛ(eòÓ®èˆNºä¾üÇ%8™a_Ô3Q“ÿNp€ ¾*Ë=štÆ.m\.TG- ãÊXrxÌG´~‹ ŸúfPÙÊ%g•GåŒş½W$C™úGÔ‘2Œ“W;}ÈAQ¬
9ÂE™,W¿şçTëş@ïÚ6‹bÚpPE:/ë—jÁò»äoˆû£æ)ƒä7MfO^ó»²ûşÛèîøŒ9;¹}Â¤±®õÉ×2KMI…cÅŞ1ÒÃˆ“$o„Å|(xEö €(Ö1—NŞ¿=É[d	Iô×71È¿®V°üº†~¹‹£²Ü_Şå%±é ıÖå(cªñ<¬7Nş®\éaÖ9Ÿ%)xÕnñb±	òÔg´Ï9ÈÇa»°'~òDË=£¿¥Ì·¹-T|gü€Md~oFªxÃƒÈš){ÁDnóïm…ó-	ÂÁDúüÁ»EW—„!=Ü1Ê¡kØ¢a<<iÊÏ­™*ş%rT“0HXÎ³£¶¡Ëqî»üÍYTfy5×­HEÜ¥Ë}NM¿‡çwáH+³Ä«ÌR£ğÅS¢+¦V'„áï5TqÛÍX†lq˜ÛátP‰Eò¯ÕJ;yGP#€}õµK¡c)Pï£Ó‹·XÑò+¼G,€‚—È´a\C·%eÍóâœ²€?1ÁÍa˜Å›.Ÿrœ(¯§Ï.èÂq¼Q¥ùğÇùğĞ7Ç²hZ#—>Õr~ä‹ÏïU(?º>³²æÇ
®ô]ñ9™¸ıùvÈ§wŠÚé„CTºëÜ“ï9`±;Ò¤Ayè”¢o7eÏ›±ø\w“ğı+yõkbîQÃG9uDÁsKÊKÖZ«Îî§·Ş‹>ÿˆ ½p#Èò£
Ğar^¾£Öñ‘êjE‰ŠPií³½<}Tº„jÌ¼®hSğ~¹9¥ó’ $UŸŠkŸM.Ú€}û99ƒ¼íeM¯-Jµr­ûqŠ/éÜbºïŸ–ÃÒ¤óQêâQŠiz´ŸQİú<ıñI2ZFhƒ]LÅ_ø½È"–%&±æàHnù?Xê¸b]¥¹®\*¡0ù—«„æ.¯=FŸh*¤Æ–«ªè]xÔöcÇb†\‹¤Ìï=%mXZæü†Pqï«`W±ï³ANÍ1‚8œŠN·&}9h–7ŒÈ²–ÇR9ªÊO;8EŒm8ßÅÁ$ÅéºğÇ,SL©Ïİ—,¯;†$ûá¶=Í¡4Q°À½d Fş¬;»4Ã2EİÜAšy	ÃëƒóÖ}°®`ä'Æ–ª8
Z9I}Æ³ÈùÌiÁi!}…°ÅâIñ˜FN×XsÁpˆÓLÒ«àû¦°pİxrÿ¶H9È¨ §ü~YËhAå-
?ùï+jÆ:tKZ´Sfİ×UF¤ˆ½<;ÕèöFá÷Ì)ŸG³´d»ãeĞ›5†+­ñrŒ®8AId¡úí8ú™Ø,­©äó•š§q²¥Îå€V:O!õ¨Š“Øû5¢IwHÇ>»^µ¹ùQI—]şY´‚ø†ı¸¢ûeßî@Ëş§Ç°8ğºLGÌbŸ	^¿‡^IÂ¥áfA–b"ŸšŒæ·	İïó%„ëÂdœ)¿q”ó66Kå-ßQÛá7Ûã\£“Ml²ç#jîiò‚’7ÕÓÜ ¥·”øbXöR¼·-àE/oÔV‘™»-é&89<){ Mx=ü!è AØß%dõîĞÆTæ‰…™Ï“ø#İ¢|´dy³2ÿÛg¡a‹O(êFçÑ. ğW:uÙg ²bjqlöG- |Ô"î¹òº}?¥‹»Öxğ[ûJ¢È¶ïÌ¨a—`|ùUlğ9×µ²º=üéS¨²wz0\¸’±y¦G=ï‡ŸÅ~Ê@'(!ë)ä“t–bä 4ĞÖˆ1ô
A8÷´^Ïûlããb{•°˜™Ğ½‚\Áb]óé˜™]´ü@5‘ì!D-L¯±† ¿ˆİcÑê×f,z*ñgqÊ€*x'‹Ğ.øÌ´ßç¬tï§­÷b5DÈÍPrEq³Û –N9ĞMZVLJÚŠğÁîR}U\òª×ô~F™Øy³£4©)OJ†Ë~¯öeq_œ­É+¬‡–e­9ŸŒÖ=¿SacØ·¦jë5âV‹s…uÉ!6*,.I@vûwğ¶µ‹xùåx`›'é.îhFÔ1Ğ'=dÒ#ë‹¼¬Çéu´ë¤Ï}P…ÒEİ&fa2¿ƒß©§èp…“öªø?6õ»¡_ƒõİ²`"âÄs'ÿ?× æÚ…ôÇF©„ãà+¼':× 4Å9ßx5ÿSn&ŠÁÈ%ºŒô)˜Á$FÚâÇ¡â?=ÛRÿŠsŠY>àÇ’©iìFÕºÔÀO—Nùè÷¥¿	ke3¶‰º%³í’œø'pİAº§ÎeÕÃ¦5bâÌ{ÂTËñ`¯+¾”'¨$¯À¨‰´oÙT?MúN» yÜe£xF$×’Ë°9” ı	&¢‹E¦U#Â?÷å¬€r±³ÈMİ
K-sÕZüXÅ¦.æÁeıùCóDÁZfEt²çğ<<c1s0yÔxle¶të%ak†n©ØäßzÊê~ÉûŸ÷º.Ğ†´Ú²F*²~¾o%oÃã¿ÏÂî›ûíkOhõöğ•2¤ı‹}Îr:7ñ‹¹9±»¢ÛHÚøÖ^¡4¶&·h¥‚†mêü:A`¯ìĞ'j{¥COCøFõÏ+xiœf…ŒĞê˜{»ÂÛ”Š¢kŸ–Ìğ8MTPÆş¦,«‡®QŒFK &ÀÛpÜ¦Š-»¤Ø˜ôÁAĞdàÇdÅø{ª‚ò’»òâŒ:”3ˆC²¸9‰Òı"½s>Í!¹¾r~ÿ=íŒ´{àyîù
Ëè„–•õÿ¡?v:êeÉiT›¿44'¥v#	«õH"ÿ$à×IåØµLjVÂ¦jÄŠ}hı$ÀXj]ãêX ÖÕ@$qå=(q|`.À/İ”¹)uÒ)‡^.ÖŸrPĞ¼ËY$üµJÇè€©ñq¾ÁgšyFì‰Cõ>§–B¶E+,- ´k @]Gj‚Š…&ŠUZäZìo«`¨c•’ 'ñçñAc¼ãpşæ6"nÖãÀå\]„ã·çfœ¹+ŸØV§"BI‰"÷Öÿu.¬Ğ‰ànëØb÷ã(Îÿ¸}G#,ÖÜ==h7 ëİ‘rHéw:]ôxÔÖ”3“^ƒšQ2ËSü­şr¤Ù½0-4E#ë ©'À{çCø¤*[˜f»?â(xC—õé –’u_{ŸÓWÍÕc‹!k‰Ä ë‚•zíÃ§HõNãÚÏXïfË–¢¦ßáÄëo†æf7ªJ2J5Î6ĞÆ7¾2ˆ~SØr9$.“õ7 4EiçXÛŠd¡è{…®¥#^“—İıD¿?¦ûü¼D”á(OÃ"7êÔüÉÎéÆ/°Ã`ÕƒÊäv/=p–hÔ|ê=U2¶pË EÓKUºœÕ¢W"Åq¾\¾5e»‚6iÉğ „Ù8Î [júæ»Äs\’&ºö ¬ÛäÄ
…dğ{
àdœzV{ez>ßDYÙÍg^7x®ÿ$½ şÄ¥ÕñÀ2%åp$è÷`}^~´§˜zOçÆğLûİI1ÆŒƒ¸~Ï‚çÊµg¡,ÆzI»wwVŞ5‘2:'O¥1ßİaxâX¹¶,&6°"7\.È[‰ñƒ® ­ÜÃØâ´ƒgñ`Å†}ê8Ú	&Û>Îç4í/rÿÀZ2Ğ#˜C•¦KR‚#Èº¢ğ5K	¬÷ÅĞOD¤2ßÔìgaÂ°¢ÉE&ò]DĞ›„˜´Hr"1T;ÁFï€-=[ı>á©YV³›¦#à+×LgŸAÀãKØ†s‰©©ë3óğ@‚ÍuáĞL/1]ë£FkÆ$iÃi‚ó€tfëã\|õYHwÁ÷·û\MÓ
¡ª*§³L“%cäüöó-Öö+Œ¬sàİôğ!EFŞr=ñĞ*jRp±jç=¿âÃS•Y¢g•2)ÖÔ„:ÃGİ~&”‘ÏñöE¥H ÙéÅ±@ÎÕ/ğş¢* ¯Ø––ë9µ-„ù$ Ós,úš¸;C"ú!¡ç©›Ê%Dõy4³¥°ÂØ~Œ>şäS\¾g—‚Q‰¯_ÀR6¶¢É¢í-ùmè»jJ=$hc’\Ú|ûN¼8^œ
‰—>Ïa~íÎy¶ suœ:3œ×2ğ©ˆbw”p¹xLĞ„iÃ÷Áàİê¯Ç¦Ût©®ãõ¹*·³éğSû[NÉŞoÊe;¾l3Á/pP¯ÇÌùyL¡O÷†¹Í¾V<}]ñ3Ì`Dj_á5æ#¸HûŸ­™€9¢,m\şW0Bq*dıA*±ä	^œ¾v©xMÊhì|6G¸@r¥Ùâ4në~l²ìüYx»0Õa3åƒt“S~‘o†ìòMâcB~z>Ò&$^1¡ˆ%z?g?)Åc€:‚k—(–(Rƒ§Rg7ÜXı«ğZŸo_ıHì»=mü5°Ş–¾Ÿ¾ÆCm(Ê„şŒöŸ&½^^TFÅãD±9ÏXóùÈaMV½>æ>§ôÒCØAÉĞªEo@AøêÃ2æÆó¼‘öRÕ©Ô,¾8Ò“ğcÍøÔÈ´ï©!C«$É:¯Ì™húÜÔrt×Œ©NäQöö ‡²‹AmbëÛ€©ï+Æ‹7S¢‚‰¸pe fıÔâe¼ßW
=é‡šŞ‘×+'/Ş»gtB·Æ–Z¯Z¼–¤+‘¼-d kŸ$´KÆ¬R®­²­³ˆ£XIC¥$h—Dqı]‡ZÂ)¯Y•¹Î™‚¬è0F"pÔğ¸6”÷¤B±ï"˜=ÖŒ~,»ú÷„5záuSK3ÄõŞV î£wâæ¦Ì2ù¸V“Şn¾C‡ÆÇšƒsj¦blşıÜªéwfcöFcG2‚ë”…9½oâÍ¸§5Aûyà_ ÁïôÚáÅÊÃ9Ãº'¹	şû¡EÇèËd½gşWQfoì¾MØÔŠNÖW®_st'‚i2ÿ³÷ö7[jCC[‰Úƒ<İ<kF9(°v,øYhM'
üzµIôÀ½-›Ú{DWRÕ*P9qwíø€ó<7"úGx"ó8Ã¡íaˆ1¡úßnïı”ó¹ÎSvåŸtŞÿíÿŸéù%ãî÷'Ï.xûXû’¼407eƒò÷:7LáIq9]¶­­ŠÅvWÙhî°C+E¿0nÜ®E\S“(Î•ORy«'\ó»í²OêÁ[Ğ&!8Ç»±jœP.iÅdN/½ U“G©RS`ÎFäkıpÅË·«|´ÖyÂ¥’~OW-*N—–Wá÷.~tr™@’šĞŠ˜Ìo³ÄÉî^ĞpYªÖ-œ_¢ÿÊFw‰›\HåÓCm+‘R–hTKs³†Sã…ô£ş>Pïk>5ê"1Äñ§Y‚¸ïv¤İ´1{Y4­±ÏÌ'$ø^ÏG©U¶›qp$Ğ	¶£KÆƒ`]}Fj™ÍõKn ö¼oµ£ç5åöî= ”Œ¥™}¡¦	xÈ[ğ(niA>¬ÖÚTÿR‹â<ù<ı[‘DçÇ­`=œò\œÿmI¸´[{Ë*¹$×ÙÁ-Ág‚W!’„0 TñKh/pº½W)ÇC9µ·sRf{7:#	§Ù<ZcŠ§Xb«êÕ	kY3ûT®è*DÃîGW#Eõ6 &èfMÜÉÙa\;¬ŸFÅüõ—åOüİËÑGÆımFP†èkjaPP,;¼„Á.ä˜î•ò_¡ÑHx…¢?¬+‡¯/†‹æZãÜWÇ‚…@íu3Ş Ë¹4pÒ^‰ŞÌ @Ê™û‹&ÖOPîó¬÷3ßBÎÂ•»ŸIoÓ´µ¾sà%¬»Ãºß¿’€o‹ôµ4e=1L÷õÿçŠËQ-ïNÑÔ±“2…~
á6²Tbä,˜Y&Òó˜êıÊ‚ß*à`m¬=a®gèGÕ\l›üİövÓÉ\/F]ï+ñÂÈÒÆ2„ß—Ëš¾Î…Ûñ$sƒ’øT[+th¤c¹é¾xp¬†Ûóô>N,ÛÂ~,ü†j&Tº;µBÓzv m®]!•dRá#bÍásŒÿo&Hv!·OƒÊƒ×Tz@ÆùŸ±(äØãR(L°ÖF}È9²ÍÏe#fWµ™	9Ç%ÆcHLœ34ËğÙÛiß”C/&6Ã²ª ‹~‹tqÅw¬Ş2‡ùõÕã š w®w¶]äY™hÖğû4ÎÍ „*óğ³kÉ×ÚÎì$µ˜é"·º™ºjıHb"–xU¨:¶4”ûÑ–şÅnDäcE·¯—Xâå)YO!_Ğö­ı@>ZÏ[	Ğ5]³«NK®Ÿ˜"À#»‚ëºå.tƒª(‡Æ™(õıÓ^–ñ½¹¶E2ÏÂNºlUPìºH3Ÿüò¤š.>RAj˜1U[½çã¦W\™3z¥–•lyÙË®Iã¸ØàVqM	ÊÊ5ÌlkÓ¹oçÌ«ÒùC}¹ÉÁ©Œı›U¹é¾hİJÜXD*vÂô}dM½ß]å¢èÑ‰Ñ%á  NW&Hó!€Aab«İêgR VN–†d‡ŞqÂo!ìŞç_ş|m4øZ:oM%,;\n„'Ù¯ºG>:àcQ™ßœ©ŞØÕÈ@ÀZÒß×Ç;¤œL¤±éOwTÒÖÂgÁ	áPgi!î_•A²¸ÊF×x'VÆU•†Ï»íØÏÌ<f·4X\gÚR†nÍië[_X-äµf]û÷y–B¬EkŸJ$"ÁB$¶T€“}©½¦ãÂœa_ÚôHb'Î½†à‡†‰ygùÆÃÓUu1¥ªâÕi]å_®9&ñ«‚âšŸüÅlxÅø6 D©*Z–Rœ¹iÇ”«’))0bËo-Ó¡y-˜'8¸˜éP)eì‹°ºV5@¤;E4´ïYç‡«R.MQ3µé	HûI“áÖÊ±êj½á3Ÿõät[š Œ2F[DÒÃhßF6ÄYÇ-¾Î+A§5æş‡89$Ù[ÂÚv	9Zm5Äˆ¼¯QyÉ£	Åı£zñ3×0»m¼-X&Ø„Ûj–Ã(³À½]òt|(šê {ò{5¯ØÃû Í&]ê Q²$üƒƒ&½î°¹ŠÓ)V"ñ•vÖµËÑ„ÀJ%oV&h©«&‹k}ì4u$Ã×W‹[ím¾ö ¼d)o Y°?'|ğ,úÔ©ºåÂä´xZ¤d^¡º²¤Ígbı$¤÷Î?B0­ •6Ü¹jĞ,ÌªëKœYPÚj“B±h\ßĞ”ŸÆA–B¤JˆS¦ìê¦\ü?L¢\öğ¯•–óo) \'“ú£\Ÿ
ŞÈá0)K"üÈ³›5–KüêŞØÑ¾rkpÌYÕ¯ÖBF>i	G-;gŞÖ‘Ù©8Må-a÷M'å?£W°ÍTrÏŸÌ°ÉØvˆŠ3C‘*[š—»-ÊL—ÍE@·S@¤§ÖBÄ#öHm|æ\Rü8·ãçÌ*¼"äÓš‡Ôœ|¼gTê¥x‹wLU$‹x>ö¾£6Éeõr›şë—Í£»°¥U Ó+Å½2è’YÂ33Û>Â"ïÀ¼ï@øÊ2¬º2ˆ—ˆUá_åó{Ÿ…£ÙBÜ¶+«ˆBb›€¹¾ Cù.
3Ù*“4°6¾6a6UÓğŒ`‚gînh˜Ù&ù~İÊ€Äµ’Ø}as„Ââà>%ø;cº8Ä¥¿w»½º~S§'i»!)òõ áçã7tÌFŞ™.˜“62q/ûóÀp.m=LÉ±Wo'yĞ‹(-}0Ø[8UÈã—`:
ñıĞæ§i¬ô½QXŞ¥sÑ¿-]¿‰Âí°èApÂ‹t8ÖTB9WqÍØâ°Y¢xöÉ°¶ƒUµcË`¤aTìÏ‡©YHÅ`Cµò©É¥Ü—æÇ[R(ı4ÁN×2o.<./DnP˜±÷Æ"wF,Zw=â0iÁQ™6×4Ë<ÈB±_ï'æ§LãUhşÑ8u‰Á.„ui’¾¡;6z]J)«€Àï‘Ÿ<§û—b‰rq„Ë=`1–×èkJ0™gï6ågjúÅ…ºˆYŞ¯Ÿß$I(Ä_ˆ‘‡&Õ[†÷à‚n:t7~a7Ó]Æ‚³ÎÄºş0Q‚Y#ß£ ¼8„äÜoÙîÑxÉõ»»cf‡"½WE¥À¼¿*ª0”“[Š]mkòÅŞ›˜Üx¨SxšuÄ»bMR$¥uNÆ³ò“
xŠàî#”øˆ|N]•µ’3ÛÏC±®¯1-‡{û.¹®a=ê®ó(9E°Îª´·uùµ"ÊÑÄ‡§Ìxq–@²µ.ûüçR¶´'“ ÎMÒ{»IS•Zúì8İéo½FÖCØlßˆPlmè?I)¨Ú§>øOÓ/iÀğøV~NV0Ê"¯Ì½,¾V¹ØM¤èˆv.f\–(ú8/D~¡Å¢ÚÂæ„ÿ|ßä‡L„ÓKJœ¡¨ ‰{=ÌÌ·uÖP¸OÄF4]Ñ6©ì‡ô{‹"„1)+ö¯Àò™®€ğÕ·ë…t5ÆÿÍV-/¶Qs¸^¿ÕíqLuåĞ½—2“-£Ó]ßĞUú/y2«cû†²M§šûu0I_×>œXßâßzßÎ Ö'IR£ˆ°¤Gô“ˆdäğìÔ|ÂœÀŒ&¤p°i!:N4VzPà­(à qD‡´sQKËº kñğİPr9T¦ŠÜİİäpÇ¡‡|@8O%(Ùeõ^¥Y'J.€“Ç¹XßÑí¦×Á+bdš¶&ô;±§e€”nQAÇÜº1Iwª” ËºùBç/U­Ê}0˜ŒÍ}—Á&
|è|qÕËÈòZ‹‚t‘Ë2gŸãÈ†/È>NÇ>¦OÑåhş~¦u“¹¥Ö6R÷÷œ-	×@7Z„áağ‚f¬¸ËÃ+éÚá)Y´QúŒ(f‰*å	6¼¢­~ZF>ï†Ğó•yõºwHû5CšÍ$ÅËœ±.x®2*2?„©5wê+L‰¾~5…/ĞE;“|D€Z‚+‚NZVÏmŠ­~«~E¾©%ÖD1sˆU5<SìÅm=†ân|{¿ûvº:‚t±Ïmñqz¹ba2rÈøîûrÛÛWU8.KĞ6ôşî~‚æM|#X	ü+cå5®a#ìŞç± Æ©½2ô*Lã²¦ß¯L¹yŞÚxÂ¶ñÃ¾í2áeëpz 52p©`yŒw{(%ß+™ãY-x 1cÕç'ğÎauÅpı#Ælâ?Ê$^ÔĞØ9Õœğ:Ôµjn³7Sô(ªjjù-Eİrïè=Kó†îşÄ6)6şšò!Á·b§±úOÏñjŠá9şÕ¦¾-FÉï4SŸímñ¾}cYH¨xtœƒ­f*XŸ?®â‰mE>mŠÃ[h¹
¾B×¬Õ€ñç+C52¬iiä §õ3WaS]@^ÚOMá\Î©Ô¢©v20q†úÑ×á‚£«¢•âÔ÷k¼Ğ€Fšóñª Mo”:~Œ`ÍÖ¹Çûn­ínº0&©ÖĞüMŠÄ#ìÇóç¹NÆüxmşãÚ¤.Ã½/Xšmá`b¶ÏCh”mÎ^ ZU±³¥ëuD
×¾ÖZ{J„[¤ûŸ+ ‚\Õ@n
xizÊçaRšô‡†Îlš:Ê=%6ækûÖJ7gyæ:ÙÊL‘šÀ¥‹b÷hEŒuY{n¥O§T‘nÖCé~[?©4äË$Äd—q`1ä¶õuSÅ!4—5ÑÓª}ñ}>Ô—bĞËÄıOâ†< 06Öêà‰­gZ˜Ï²jüáér•&zÎ} ÃIô8Ä±ğªp&pLòk"” ¥>1˜½³§ı™JiÊ]O¤YOA€L[ÅØGôl&ı×g»6~şÊ“gˆÅ@ÊiTÕ=5,F>Ùş-±,Ğ6±ßHÀÛçÿªLTêtéxù×¯İBğ¥Â‰jµ-ÙLƒòë§1bM`ú6ı–7â	:çÔÔ2t[Gc]¢5ô’Ú.¨¢ÅâS[6¡f{îØ1{‘5\ôdv"ËÀú·_}”xv5M¥'(ñ­{Çó‚^Øé–i…CÇánFØOéß´9*œ3	!ÂğÚ›¬VBÒFP k¦zùöDô±¾šşH_)_)Rn)y5Òäœ…yy\p	Hjüd?Q,•…ëš²ˆ¹l+™Çù¼Qh–˜PİåŞ@j—l¸¬x¨«zé€š
ñIä«ÑyUkQ­Bb€¡»Î½"ü•i]Ÿöè@^Š'ö4;zs'%7]ŸO™¹Ö-wù d7S|aeÔ§|—X¢Œ@«'‡áÃ?g—ãoO¢i±À'Æ,o¡9(©ïrñ‚…»jµĞFàŒïvÓMŒÊí¾AÔUÅMÄ&1ï¼["¤;Ym€‚EdÔ¼9Ğš2\ ürò¶µn-›¼‰¢U¼-„è¶=»Î;iõ•-NœSÛ®åÃüCtä”.°Á‚=h#{4öŞáAÍ&®åŠì™3?wæHHöKBÆÚ‹„7-á²ZXªâµîm òâFY<êãWÁP<Œìo2z£|ô£ŒçUPÌíÓ‰`ı QR*Üh'i_ ·×u„„(dÌötVNç•üYÕë­\^Ôà!ì;ÿ2±àvˆeåˆÇ@± ¶Ù5€„;#2èœ“4Ô¬²F;'·Õáš'NàX“ã~¿%zÚz²^ºsDtª!ò–f²ÂXpÇíïˆäzuÙàkbA„€ì“ƒºşŠ°á·é8ÎÁq‘_¯8òÈûÌZúª´çŒ‘²îÇ$"1f¸—B\ı~ÂıØ\‹-*zÑùÂ)U`Wİ¾í5ØgÕÎ Xã±^³¥ØÊ‹ï{!8˜UlŠªÍñø+=I “ãƒŠ]¾äâïáz³ãŒ”Kƒ¢0¨…[‰İ.ÄÇ	-şC{ŞÙb«ø½|“yeØš›
ÿBq¹+ÙâW†'i¬y‘
¶Â)Ì¦Ì¸ì§¼`Jp	áN2ÈkáŞS"ÊhÁ>Ş»Î¤q~¡D[ßKé!QiÛyH¬ö‚6ûp¬.õäA«†PÑŒ¶Ú«>z˜ĞşıeÛ€|)|’†Au¸|n_Ñ·ÔtÊ-]QÎö2-Ê]éuÙ)ç˜°t‡g)¿Ñ£O×I½7p?¢İhåyîéŸ—ÕÎ, KWIwÓ`3–mËôä#NMY“$£B³Ubi}ñ}Ó§ÎüuU'Údú÷ÔÓ¯êpöZ4¯—ÃÙ7$ˆv@Eı/:èBCbé´ÒÁd¡Üs:¼¡B¥ä_¿(CªéêJ·Ûñ$…¤ñÂJ§“R[|±:’??*p¢CN¶O“mœÕoq™¸å$´‹‚ºZzŸ¥¾F"FdöŞ¨9U?ª\Ïìœ{ğÇ‹X,›O¿\†Şuí|Rá°¦vãØJ‹¯^	?;~ßÉ»™5&¤àÒ=mlnSú2z!0ã\Ÿ†ü)Ö”0ı™#EdJm²Øä‰¾É²,“¥xıj-0ï™LR3
’^Àôéğ±'µâ<4$º´É·ÌøŸ™XuºhDˆ¸¥7 ¢Hqìš·PÛkÒ7?'‰¼+(qEñÂ?î£·vuZ±µI°@8ÈËõ[³)¹¨§zˆHŞ@fH¬,Ÿçªfv’½°5SÑªN“©ÓG8"du”_,*äùÓ{8ĞY0%û4ŸÊÉµnÑ=µ¤–ğVÊ“ŒìÒ‰¤wò´aö‘äÏK‘ÉkºÒòû®xOpÿí‘Äx¾®ŒaßçmŠ×ŒÏáö(ÉëøÛ¬:og.ù&B×<ÎÏ1ªÑ¨Ü*>N‘â±…b|ñÿãŠ3Û¦3>t!{m¦µœ^dqlÓe<â¨,şºÔcÇš-ó­©qd–µNú°/çï6ãÓ°ú’´ûr=Åb.ªAi´ß°’šÆ|o±I7ó+»Íñúï•ÍjÆgÌ*ZWÎŸ…ºƒÿÄµíëÿ¹åzÔÄÑ0P·òe4á•XØb<1À‚ùx=µ”:Ì_›¬AÔˆˆpûºˆuŒ	ü·ŞM²ä›áF„6-Õhô Á›y“)ïEÄ:|}‘y÷JÙ:œ~5'Kâšè]ı'H{Ã-F(CH÷Ú†(‹àfeUô5Û¥ö‚òÈ
÷™‚º—‘¾6˜	İ^ß6y®¦¨¬iÓ	§“† Î
uá–ìÆd\Üx¦33ñÏ¡dbŠ?kˆe+PØØó[k4<[Cè_ÿ¸+³ù‚d¶•P¼F²1:`dò·P©«sî˜
£(nÚsEõ!</3“`iè%†éÌà‹i?ã’mÍªä“ëZ2‹›úfÖ!DÍ´HyuTü.$æ¿úš½EüŒ°l«iğ?s/mºf°"Âä†oQrê³Ñv‰fÁ×·¾Ã>	ÅÑ¾*bjU¼îí¯=âsÆ‹ö?Exbğböˆ²/?Ãë§GßÆ`)¾5ıD­i;q‹Üõô$¡N»Fo@ñğ}fŞ­ı©©#| „Î âßsàÈqÜb[\
•m˜üú	-Õ…ÿ›È	&ÑkĞ<gY3§‰÷’feà*Ú—¬ÿÿô“rÕ|ˆÜ‘F`–Ù!­l&‰Ú¾Yÿ˜à1´í÷QîPˆŞ”g_vNãÄ*¹7±3ŸùS†ÙfL¸iŞ•ÎØAÅ—»6‘PöÏHÍ·)F!·É…)e<b€˜ØÕC)P¥¿ÓÑwg]êxø¬jU»Ğ0'¾‘-¯jeâ«İ 7¡Ş›‘•´–º^2;I3øfÓ˜«ÒáÒé?ÚŸ%cáiÖŸ1.ÈæìùTc§‡³qLã„Á„}«Ô½¬ÿkyS›4»•õöçÜgç8BÇÏc|ã|fåÒºö°æ¡ïç5EL‹hX¨­©Tè4ÿ9j=9bÕÈ9™'½£ÀÒ%ú‹N>ßÈ9ulTNp¨Ê}eÛèàsëŒØÜ‹h©‘ğËgI
Vç¹_ÁğÁmMPZõQ™vÄ…Â®ÜioŠü¿JÇÃës5ÛLUC¡µDlîRjŞxú·­õW^äeÉTqÎ‡N„puæóp¢T•ıeæÚrŞ0•Øæ—óÕ›7UßZO"Æà©È;ê{B…é4ıÚukA´±iœ[ì‡‘ËGâyÁ<°{ä°Uáúµ½{™;lªŒ¶¢LòÂÈ«\N$\EùRÃN£ÆôÊòûnĞ4WÄ>š*,Âb©°Äk¡>°B›ÉÉÁúµR0ÀÏpØe„°hEñÉÀ=‡z* ïã‡ñ2Ø˜UP_¿øØÒ·]xc_,œÉJ˜t_èX¸ÔaÌÍËâ<.fö¾İƒTÅ³CÈ!
“óÿqÀí/kÒÜƒB›3{`@ßh^˜ßŠÁ0÷Eüm°"Â^FÑråzíÆ¡áöÇÄZª-!fÙÒCÚfôøX%Â÷‰sæißÉxTê	İßÇà! ~ñ?úQy\ÿ³‘$~PÅ[Š×ì‰3äû&®.¶!§ÓbAŸ­9z…4€¬å·VÈXFZ“YlöeWÛ¸gD/Ö‹ÔáH8VØe7ç³¤ä×Ëš•@¯êı«{l@7N:²ÂpÂÇ~“â	9xR!Ìrv-H¢d¼ºŒ bfxåGc_]6ªÏtû)4§¾~¯ãåu4Ğ)‰Ê‡h)üÚÓp8š¡¼(Æ,©ø’‹!â™öpáz,
¹hø¡’A´‹Ş¦¸´t#hŠE`Ä4ÊÆ”Ş8‚6’ƒ(‚-íqRi§ç¾tq´D¼òs"0òuÔ‡ÍDÄiØ–ÅqË½ô@°ë¹;Æûá>µø¸²Zr„Iı¦éÂ¸O2•+»z¨w‘gı…k²¯Ã·ãoŞgÇ%ë‘‘Xòş˜§ø*Ö«\6FoyÚf&íSSSiõÈszÑäYTâ´ŸR]%Ñ§3Ërt¦,ıwÕ«à­¿ö›¸«-k)-¾Jk+oX±Nşd«±-ıs@îÌs }æ(úOÅqÄÇèşÖv³ÁÛ±D¬½ñ\Å']Mk
%21Ï÷ù}ó ®²z-ò‘Œó¥·±Ñl™Ë’‹Øçá<„qœà_	Üç\|‰k
â³¢·ŒS=îôj{ağhÛ(ª±¿¶ ÃÜ„˜Ûxõµu¯Å¢o~`J¢#GqZÃPùÂ¨,} KcêsrEF¬i3Ã›#\#BÙ¡)[¿šF~“¿4?ãSÉ´˜Ç‘|ašØB½­ˆf\³ù!uÆPlÈ!±ûæ“94µ­aK6ü‡Q¶„bÁ_¿£x_\ëW¿F@‘ÆŠNöÉ¦Ç¾7¸¿O»í5®ŒÍqMf‹f³×µÿø@£à…§nË\ûú¿%æ™TÅè’Î>Zá{õeOsab/M8gõ#„÷HV¦­o)‰S±¯¯Æ×;#6|ÊˆÌpdëèÚ”L«åú3Yş<4nzş·%²l¤kÂµ	?&`E=ÂŸlñº®0vU‹’úPWuÎ÷Î'l=R!ÏEš%úxd­›îØ”FİQ5l«ÂdÜa.C_Öœè“v[€sp¨kvŞ‹\\ ùƒûzV„m¼ˆ¤2?9Øİ¶?[pÀ|Ø™öO,Úfyt9òÅÚï8'÷ç)àŞKŒtÓ-L¶ç×/E%‘€N3F–=f™òñIj–¬ÍXES&ÏeFÀ?(”!‘™nãyÖü§T6şùß±heCüEÂ{sÛÅ7òşŸg"kº?ÓãcEÜ}eF°ëå7×¦ŸD!|¶:tKy5!#x´HÛR‚œa”äêeOÚš¸İÕˆ$x°ø:¸y–Ùœ%¾rfaé+úùJÇÁÉÍÌğ`©›‡b'fRÌ‘ó‰á¾ùrÍÎ‹¬2!«ÖƒÊ<óGÚYT™›…j|yz`şmTéJÊnİ;Æ_ĞÓÊ•Õ[–ìöšx2û_óCòYrïğd‹DÎàäiâY^wLÀ§ùê¡ß¼LJüíRš_	ziJÒpc—gÀÂ”¿8&°À»ºVêg
ì™ãİÖR*ü]R¬|ü‘ßàK¯¡XçOÑÁÃ?ÿ9H"pKx#²…ªn‰%½±oEU*ıŞù<Íìë}	ªÊwâ³qåFÒF)DVlÏnŞSœSS¢ÒMİ]gôqÁ|v¢øûuv~Úl·;´äDÛ7ì9_F±ECß9Uö´M\~ùÃ[C$éFbt i«Q²%WsÁ+ŠÕô½b&Ğ0Ø“{â)&C¹·tÛÌp\l›	[Ç¦L²gØİKÓíÀ¬>CÖq-¦Hn¡úñØÛp~
ñ‚²= çb#¡¸;©Z	">œqé)ƒ²¼r?ØÛa¥«Ä…ãÃ]s&(é¡‡vg!¶TMXBs|™|3cæy³$ğË=şˆù4…èûÀHíõ:¹‰æ.qó8Æ”¸m…çêM·EbÚÕÆXI\õ9A¿Óğ¨ÍYHŞ‰Ê¸øä& »H~_õ”»:š¨Œ8Cz‘Kß€íÄ¶µoL£_.æLŸÔ}u	ÏV°ê!èkæã#ê­l¸¯ÀTÈ‡»ŸÃğo—Iš6¶r- ÉS9®åŒh…ˆxÁ‰¿ÑH0qmäefãŞŠø€=^R~<kZ—Ò/ÄGUa…¹ûÉ/Mp…ˆ,$e¨B¤ÃÆ ÛŒ/ıõ¢0(¡ÿôäQå¯‘27Ù+ Ó–/©Â3Ê¿QŒ¹jŸ)ÍÉÓª8lİÆ6¬‚ñëizØÕS4Æ6™Ñ\Ğ‘ùQº6.Ğ°íÂøÚ~Sª£Éwù<ŞÑR$€k¡vL8‘oá3 Ë%Muim>pìh½phÇ¤­â¹K‹Œ õ"‰ëHĞ©@øŞ	¥o—pGÈ(Ãj¨è!S/Ú–§®å6ó]<c2Õ·ò3o†ïøÕ}v›¡µIË4œ–' ˆHuoZeÆ¯4Ú©®”cıP.ƒ–Lá0’!aÇ)š[³[âˆªYa½A³(®BÌÍ¨æ"9ËÈé¶`¯o'8/:VÓta—hi¿;?âIÜ ¿Dı‚Éh'¤d°ŸG2·¼ªÌYGfÄÒÖŠÊëı6D÷Yuª˜:c»íe¦¬)Ui¤Î»öœ×´{Ú­=e'Ê$÷Ä~2äÇâ5N‡˜OlàÄü¾ÅÇ³jÂ’©ÂGó¶ÍğÊ#FÈÄª8„·<ª~7,¶¹dRA› ^/“/Ùsµ"ô‚Lc¯şŞÜ¸#ã!şÔiÃ¯¾¯Š‹aÜû5$™8ú¿õ{yŒsgiHa£ÕêòÄ k¹ıaGß†höÿSnÆ2zc´U€f{¬úrY8œ™ïaû™Ç:ŠRãË±~ô\Rì(  w3É:ÊÎ}Ç\mºÕ'i1ïÈ1øW±û1f¦5KÔ@Õ(¨rCÀßVj¨ÎEúã7¦LÓğëH(?ç™ˆ3Y~	øzX­­eÉyø…†Áb½nG½Ñéå³š…[Ãiè…MNÃõ?$:G ï¯÷şçd°-a¨ÕŞú'ƒ×²œÄ£™•ñ±œœc¦ßpuBkŸRñ¢×÷LÊèÄK(ÓÅ¥ºÉQYj4ÏLã&J0Ò3¶š8‚*Ÿ!Û9xš¡ô{¥3wìøœ¤­Ío›ûö‡x_)Uù>—l–°£Ÿé‚Ç’7v¯T2æçB.ï÷H51¸Y;É/k"x4Áº›‹ÕtMY°G ÌÍy—[œñ°éPM… ª†]6ÍDd6Ï“BS„ÛaŒƒ–{2f…fÒŒõÊ¥ÛdU½ˆğ­"°tÒ‰VÂU|ybO¾öìİ£´äMİ›
ÇVóÀ·;WÎõÄb1§õµ0nÖñÜ¤Ğ°ŸP%¥ è+æàB|~ÀÉÜÌtaá¢Åƒ¨Æ{	Q{ƒ(¥(ÔI^×;=9.¡;,³í¥]Ä…ã\H¶İt1‘à°÷¯A\ûA®Î˜¦ælD•%ØAË.:v2Äùá^'ÕDÂG|Â6ìMüL–½ÒØi[b6š]pi×#·iˆöÛÑ2Y‡Ş³dICš×,³—)š˜éöØ×‚+Œ @…ğ ájD¢«k%(×@F~bóä€wkñB`°†íQÉûÖÒñ†•®Åªÿ‚³ù¬Ê•ó”:šGØL66Yê¡¼€˜¯/6wÁd¨n8õ»ù¬)ŒKåRY¯O©»îy“Ÿ¥%½I:èÆ8xy<,.@Ñmj@K]å„>y”º ret = self._unpack(EX_CONSTRUCT)
        except RecursionError:
            raise StackError
        self._consume()
        return ret

    def read_array_header(self):
        ret = self._unpack(EX_READ_ARRAY_HEADER)
        self._consume()
        return ret

    def read_map_header(self):
        ret = self._unpack(EX_READ_MAP_HEADER)
        self._consume()
        return ret

    def tell(self):
        return self._stream_offset


class Packer(object):
    """
    MessagePack Packer

    Usage:

        packer = Packer()
        astream.write(packer.pack(a))
        astream.write(packer.pack(b))

    Packer's constructor has some keyword arguments:

    :param callable default:
        Convert user type to builtin type that Packer supports.
        See also simplejson's document.

    :param bool use_single_float:
        Use single precision float type for float. (default: False)

    :param bool autoreset:
        Reset buffer after each pack and return its content as `bytes`. (default: True).
        If set this to false, use `bytes()` to get content and `.reset()` to clear buffer.

    :param bool use_bin_type:
        Use bin type introduced in msgpack spec 2.0 for bytes.
        It also enables str8 type for unicode. (default: True)

    :param bool strict_types:
        If set to true, types will be checked to be exact. Derived classes
        from serializable types will not be serialized and will be
        treated as unsupported type and forwarded to default.
        Additionally tuples will not be serialized as lists.
        This is useful when trying to implement accurate serialization
        for python types.

    :param bool datetime:
        If set to true, datetime with tzinfo is packed into Timestamp type.
        Note that the tzinfo is stripped in the timestamp.
        You can get UTC datetime with `timestamp=3` option of the Unpacker.
        (Python 2 is not supported).

    :param str unicode_errors:
        The error handler for encoding unicode. (default: 'strict')
        DO NOT USE THIS!!  This option is kept for very specific usage.
    """

    def __init__(
        self,
        default=None,
        use_single_float=False,
        autoreset=True,
        use_bin_type=True,
        strict_types=False,
        datetime=False,
        unicode_errors=None,
    ):
        self._strict_types = strict_types
        self._use_float = use_single_float
        self._autoreset = autoreset
        self._use_bin_type = use_bin_type
        self._buffer = StringIO()
        if PY2 and datetime:
            raise ValueError("datetime is not supported in Python 2")
        self._datetime = bool(datetime)
        self._unicode_errors = unicode_errors or "strict"
        if default is not None:
            if not callable(default):
                raise TypeError("default must be callable")
        self._default = default

    def _pack(
        self,
        obj,
        nest_limit=DEFAULT_RECURSE_LIMIT,
        check=isinstance,
        check_type_strict=_check_type_strict,
    ):
        default_used = False
        if self._strict_types:
            check = check_type_strict
            list_types = list
        else:
            list_types = (list, tuple)
        while True:
            if nest_limit < 0:
                raise ValueError("recursion limit exceeded")
            if obj is None:
                return self._buffer.write(b"\xc0")
            if check(obj, bool):
                if obj:
                    return self._buffer.write(b"\xc3")
                return self._buffer.write(b"\xc2")
            if check(obj, int_types):
                if 0 <= obj < 0x80:
                    return self._buffer.write(struct.pack("B", obj))
                if -0x20 <= obj < 0:
                    return self._buffer.write(struct.pack("b", obj))
                if 0x80 <= obj <= 0xFF:
                    return self._buffer.write(struct.pack("BB", 0xCC, obj))
                if -0x80 <= obj < 0:
                    return self._buffer.write(struct.pack(">Bb", 0xD0, obj))
                if 0xFF < obj <= 0xFFFF:
                    return self._buffer.write(struct.pack(">BH", 0xCD, obj))
                if -0x8000 <= obj < -0x80:
                    return self._buffer.write(struct.pack(">Bh", 0xD1, obj))
                if 0xFFFF < obj <= 0xFFFFFFFF:
                    return self._buffer.write(struct.pack(">BI", 0xCE, obj))
                if -0x80000000 <= obj < -0x8000:
                    return self._buffer.write(struct.pack(">Bi", 0xD2, obj))
                if 0xFFFFFFFF < obj <= 0xFFFFFFFFFFFFFFFF:
                    return self._buffer.write(struct.pack(">BQ", 0xCF, obj))
                if -0x8000000000000000 <= obj < -0x80000000:
                    return self._buffer.write(struct.pack(">Bq", 0xD3, obj))
                if not default_used and self._default is not None:
                    obj = self._default(obj)
                    default_used = True
                    continue
                raise OverflowError("Integer value out of range")
            if check(obj, (bytes, bytearray)):
                n = len(obj)
                if n >= 2 ** 32:
                    raise ValueError("%s is too large" % type(obj).__name__)
                self._pack_bin_header(n)
                return self._buffer.write(obj)
            if check(obj, unicode):
                obj = obj.encode("utf-8", self._unicode_errors)
                n = len(obj)
                if n >= 2 ** 32:
                    raise ValueError("String is too large")
                self._pack_raw_header(n)
                return self._buffer.write(obj)
            if check(obj, memoryview):
                n = len(obj) * obj.itemsize
                if n >= 2 ** 32:
                    raise ValueError("Memoryview is too large")
                self._pack_bin_header(n)
                return self._buffer.write(obj)
            if check(obj, float):
                if self._use_float:
                    return self._buffer.write(struct.pack(">Bf", 0xCA, obj))
                return self._buffer.write(struct.pack(">Bd", 0xCB, obj))
            if check(obj, (ExtType, Timestamp)):
                if check(obj, Timestamp):
                    code = -1
                    data = obj.to_bytes()
                else:
                    code = obj.code
                    data = obj.data
                assert isinstance(code, int)
                assert isinstance(data, bytes)
                L = len(data)
                if L == 1:
                    self._buffer.write(b"\xd4")
                elif L == 2:
                    self._buffer.write(b"\xd5")
                elif L == 4:
                    self._buffer.write(b"\xd6")
                elif L == 8:
                    self._buffer.write(b"\xd7")
                elif L == 16:
                    self._buffer.write(b"\xd8")
                elif L <= 0xFF:
                    self._buffer.write(struct.pack(">BB", 0xC7, L))
                elif L <= 0xFFFF:
                    self._buffer.write(struct.pack(">BH", 0xC8, L))
                else:
                    self._buffer.write(struct.pack(">BI", 0xC9, L))
                self._buffer.write(struct.pack("b", code))
                self._buffer.write(data)
                return
            if check(obj, list_types):
                n = len(obj)
                self._pack_array_header(n)
                for i in xrange(n):
                    self._pack(obj[i], nest_limit - 1)
                return
            if check(obj, dict):
                return self._pack_map_pairs(
                    len(obj), dict_iteritems(obj), nest_limit - 1
                )

            if self._datetime and check(obj, _DateTime):
                obj = Timestamp.from_datetime(obj)
                default_used = 1
                continue

            if not default_used and self._default is not None:
                obj = self._default(obj)
                default_used = 1
                continue
            raise TypeError("Cannot serialize %r" % (obj,))

    def pack(self, obj):
        try:
            self._pack(obj)
        except:
            self._buffer = StringIO()  # force reset
            raise
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_map_pairs(self, pairs):
        self._pack_map_pairs(len(pairs), pairs)
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_array_header(self, n):
        if n >= 2 ** 32:
            raise ValueError
        self._pack_array_header(n)
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_map_header(self, n):
        if n >= 2 ** 32:
            raise ValueError
        self._pack_map_header(n)
        if self._autoreset:
            ret = self._buffer.getvalue()
            self._buffer = StringIO()
            return ret

    def pack_ext_type(self, typecode, data):
        if not isinstance(typecode, int):
            raise TypeError("typecode must have int type.")
        if not 0 <= typecode <= 127:
            raise ValueError("typecode should be 0-127")
        if not isinstance(data, bytes):
            raise TypeError("data must have bytes type")
        L = len(data)
        if L > 0xFFFFFFFF:
            raise ValueError("Too large data")
        if L == 1:
            self._buffer.write(b"\xd4")
        elif L == 2:
            self._buffer.write(b"\xd5")
        elif L == 4:
            self._buffer.write(b"\xd6")
        elif L == 8:
            self._buffer.write(b"\xd7")
        elif L == 16:
            self._buffer.write(b"\xd8")
        elif L <= 0xFF:
            self._buffer.write(b"\xc7" + struct.pack("B", L))
        elif L <= 0xFFFF:
            self._buffer.write(b"\xc8" + struct.pack(">H", L))
        else:
            self._buffer.write(b"\xc9" + struct.pack(">I", L))
        self._buffer.write(struct.pack("B", typecode))
        self._buffer.write(data)

    def _pack_array_header(self, n):
        if n <= 0x0F:
            return self._buffer.write(struct.pack("B", 0x90 + n))
        if n <= 0xFFFF:
            return self._buffer.write(struct.pack(">BH", 0xDC, n))
        if n <= 0xFFFFFFFF:
            return self._buffer.write(struct.pack(">BI", 0xDD, n))
        raise ValueError("Array is too large")

    def _pack_map_header(self, n):
        if n <= 0x0F:
            return self._buffer.write(struct.pack("B", 0x80 + n))
        if n <= 0xFFFF:
            return self._buffer.write(struct.pack(">BH", 0xDE, n))
        if n <= 0xFFFFFFFF:
            return self._buffer.write(struct.pack(">BI", 0xDF, n))
        raise ValueError("Dict is too large")

    def _pack_map_pairs(self, n, pairs, nest_limit=DEFAULT_RECURSE_LIMIT):
        self._pack_map_header(n)
        for (k, v) in pairs:
            self._pack(k, nest_limit - 1)
            self._pack(v, nest_limit - 1)

    def _pack_raw_header(self, n):
        if n <= 0x1F:
            self._buffer.write(struct.pack("B", 0xA0 + n))
        elif self._use_bin_type and n <= 0xFF:
            self._buffer.write(struct.pack(">BB", 0xD9, n))
        elif n <= 0xFFFF:
            self._buffer.write(struct.pack(">BH", 0xDA, n))
        elif n <= 0xFFFFFFFF:
            self._buffer.write(struct.pack(">BI", 0xDB, n))
        else:
            raise ValueError("Raw is too large")

    def _pack_bin_header(self, n):
        if not self._use_bin_type:
            return self._pack_raw_header(n)
        elif n <= 0xFF:
            return self._buffer.write(struct.pack(">BB", 0xC4, n))
        elif n <= 0xFFFF:
            return self._buffer.write(struct.pack(">BH", 0xC5, n))
        elif n <= 0xFFFFFFFF:
            return self._buffer.write(struct.pack(">BI", 0xC6, n))
        else:
            raise ValueError("Bin is too large")

    def bytes(self):
        """Return internal buffer contents as bytes object"""
        return self._buffer.getvalue()

    def reset(self):
        """Reset internal buffer.

        This method is useful only when autoreset=False.
        """
        self._buffer = StringIO()

    def getbuffer(self):
        """Return view of internal buffer."""
        if USING_STRINGBUILDER or PY2:
            return memoryview(self.bytes())
        else:
            return self._buffer.getbuffer()
